// $Id: object_parms.ds 1360 2015-06-16 08:36:25Z kik $

collection {
    name "ar_object_parms"
    label "Arnold"
    parmtag { spare_category "Arnold" }

    group {
	name	"folder_subdivision"
	label	"Subdivision"

	parm {
	    name	"ar_subdiv_type"
	    label	"Type"
	    type	string
	    default	{ "none" }
	    help	"Subdivision algorithm. None ignores any subdivision and renders the mesh as it is. Linear subdivision puts vertices in the middle of each face. The Catmull-Clark algorithm is used to create smooth surfaces by recursive subdivision surface modeling. The resulting surface will always consist of a mesh of quadrilateral faces."
	    menu	{
		"none"	"None"
		"catclark"	"Catmull-Clark"
		"linear"	"Linear"
	    }
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Subdivision" }
	}
	parm {
	    name	"ar_subdiv_iterations"
	    label	"Iterations"
	    type	integer
	    default	{ "1" }
	    help	"The number of iterations / levels of subdivision. With Catmull-Clark subdivision, increasing the number of iterations produces a smoother mesh."
	    disablewhen	"{ ar_subdiv_type == none }"
	    range	{ 1! 10 }
	    export	none
	    parmtag	{ "spare_category" "Subdivision" }
	}
	parm {
	    name	"ar_subdiv_adaptive_metric"
	    label	"Adaptive Metric"
	    type	string
	    joinnext
	    default	{ "auto" }
	    help	"The adaptive subdivision criterion. Auto subdiv will choose between the EDGELENGTH mode and the FLATNESS depending on the displacement property of the polymesh. This means that if there is a displacement it will use the EDGELENGTH algorithm. If there is not displacement (or it is ignored in the global options) it will use FLATNESS."
	    disablewhen	"{ ar_subdiv_type == none }"
	    menu	{
		"auto"	"Auto"
		"edge_length"	"Edge Length"
		"flatness"	"Flatness"
	    }
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Subdivision" }
	}
	parm {
	    name	"ar_subdiv_pixel_error"
	    label	"   Pixel Error"
	    type	float
	    default	{ "0" }
	    help	"The \"pixel error\" refers to the acceptable tessellation error as seen from the camera, in pixels. If there's no displacement, then the pixel error represents the distance (in pixels) from the subdivided mesh to the \"true\" or \"limit\" surface -- sort of a \"flatness\" heuristic. The smaller the error, the closer to the limit surface a mesh will be and the less inter-frame popping when the subdivision level jumps. If displacement is enabled, then the pixel error represents the final size of the subdivided quads (again, in pixels). A value of 0 disables adaptive subdivision."
	    disablewhen	"{ ar_subdiv_type == none }"
	    range	{ 0! 10 }
	    export	none
	    parmtag	{ "spare_category" "Subdivision" }
	}
	parm {
	    name	"ar_subdiv_uv_smoothing"
	    label	"UV Smoothing"
	    type	string
	    default	{ "pin_corners" }
	    help	"UV smoothing algorithm."
	    disablewhen	"{ ar_subdiv_type == none }"
	    menu	{
		"pin_corners"	"Pin Corners"
		"pin_borders"	"Pin Borders"
		"linear"	"Linear"
		"smooth"	"Smooth"
	    }
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Subdivision" }
	}
	parm {
	    name	"ar_subdiv_smooth_derivs"
	    label	"Smooth Derivatives"
	    type	toggle
	    default	{ "0" }
	    help    "This option makes it possible to remove the faceted appearance from anisotropic speculars. The object must have a valid UV map for this option to work and only works if you apply at least one subdivision level to the geometry."
	    disablewhen	"{ ar_subdiv_type == none }"
	    range	{ 0 1 }
	    export	none
        parmtag { "spare_category" "Subdivision" }
	}
	parm {
	    name	"ar_subdiv_dicing_camera_enable"
	    label	"Use Alternate Dicing Camera"
	    type	toggle
	    nolabel
	    joinnext
	    default	{ "0" }
	    help	"Enable Alternate Dicing Camera."
	    disablewhen	"{ ar_subdiv_type == none }"
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "script_callback_language" "python" }
	    parmtag	{ "spare_category" "Subdivision" }
	    parmtag	{ "script_callback" "hou.hscript('opparm -b %i . ar_subdiv_dicing_camera' % (not kwargs['parm'].eval()))" }
	}
	parm {
	    name	"ar_subdiv_dicing_camera"
	    label	"Dicing Camera"
	    type	oppath
	    default	{ "" }
	    help	"This is mostly useful for debugging and rarely used in practice. When enabled, the user provides a specific camera that will be used for all dicing calculations during Adaptative Subdivision. By default this is disabled, meaning that the current render camera also serves as dicing camera."
	    disablewhen	"{ ar_subdiv_type == none } { ar_subdiv_dicing_camera_enable == 0 }"
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "oprelative" "." }
	    parmtag	{ "opfilter" "!!OBJ/CAMERA!!" }
	    parmtag	{ "spare_category" "Subdivision" }
	}
    }

    group {
    name    "folder_displacement"
    label   "Displacement"

    parm {
        name    "ar_disp_height"
        label   "Height"
        type    float
        default { "1" }
        range   { 0 10 }
        export  none
        parmtag { "spare_category" "Displacement" }
    }
    parm {
        name    "ar_disp_zero_value"
        label   "Zero Value"
        type    float
        default { "0" }
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Displacement" }
    }
    parm {
        name    "ar_disp_padding"
        label   "Bounds Padding"
        type    float
        default { "0" }
        range   { 0 10 }
        export  none
        parmtag { "spare_category" "Displacement" }
    }
    parm {
        name    "ar_disp_autobump"
        label   "Autobump"
        type    toggle
        default { "0" }
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Displacement" }
    }
    parm {
        name    "ar_autobump_visibility_camera"
        label   "Autobump Camera Rays"
        type    toggle
        default { "1" }
        help    "Toggle autobump for camera rays (i.e. primary or view rays)."
        disablewhen "{ ar_disp_autobump == 0 }"
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Displacement" }
    }
    parm {
        name    "ar_autobump_visibility_shadow"
        label   "Autobump Shadow Rays"
        type    toggle
        default { "1" }
        help    "Toggle autobump for shadow rays fired in the direct lighting calculations."
        disablewhen "{ ar_disp_autobump == 0 }"
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Displacement" }
    }
    parm {
        name    "ar_autobump_visibility_reflection"
        label   "Autobump Reflected Rays"
        type    toggle
        default { "1" }
        help    "Toggle autobump for mirror reflection rays."
        disablewhen "{ ar_disp_autobump == 0 }"
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Displacement" }
    }
    parm {
        name    "ar_autobump_visibility_refraction"
        label   "Autobump Refracted Rays"
        type    toggle
        default { "1" }
        help    "Toggle autobump for refraction rays."
        disablewhen "{ ar_disp_autobump == 0 }"
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Displacement" }
    }
    parm {
        name    "ar_autobump_visibility_diffuse"
        label   "Autobump Diffuse Rays"
        type    toggle
        default { "0" }
        help    "Toggle autobump for indirect diffuse rays (i.e. global illumination, hemi, or GI rays)."
        disablewhen "{ ar_disp_autobump == 0 }"
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Displacement" }
    }
    parm {
        name    "ar_autobump_visibility_glossy"
        label   "Autobump Glossy Rays"
        type    toggle
        default { "0" }
        help    "Toggle autobump for indirect specular rays (i.e. glossy reflection rays)."
        disablewhen "{ ar_disp_autobump == 0 }"
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Displacement" }
    }
    }
    
    group {
    name    "folder_shapes"
    label   "Shapes"
    
    parm {
        name    "ar_min_pixel_width"
        label   "Minimum Pixel Width"
        type    float
        default { "0" }
        help    "If this value is non-zero, points or curves with a small on-screen width will be automatically enlarged so that they are at least the specified size in pixels. The enlargement fraction is then used in the hair shader to adjust the opacity so that the visible thickness of the hair remains the same. For a given number of AA samples, this makes it a lot easier to antialias fine hair, at the expense of render time (because of the additional transparency/depth complexity). Good values are in the range 0.2 to 0.7. Values closer to 0 are faster to render but need more AA samples. So if your scene already uses very high AA settings, you should use a low value like 0.1. For best results, you may need to increase the auto-transparency depth, and/or lower the auto-transparency threshold, but watch the effect on render times. Note that this parameter currently works with the ribbon mode only."
        range   { 0 10 }
        export  none
        parmtag { "spare_category" "Curves" }
    }
    parm {
        name    "ar_radius"
        label   "Default Radius"
        type    float
        default { "0.05" }
        help    "Sets the default rendered radius of points or thickness of curves. This property can be overridden per point with the \"ar_radius\", \"pscale\" or \"width\" (curves only) attributes."
        range   { 0 10 }
        export  none
        parmtag { "units" "m1" }
    }
    group {
        name    "folder_points"
        label   "Points"

        parm {
        name    "ar_mode"
        label   "Mode"
        type    ordinal
        default { "sphere" }
        help    "Rendering mode for points or particles. Can be spheres, or camera-facing disks or quads."
        menu    {
            "disk"  "Disk"
            "sphere"    "Sphere"
            "quad"  "Quad"
        }
        range   { 0 1 }
        export  none
        }
        parm {
            name    "ar_point_scale"
            label   "Point Scale"
            type    float
            default { "1" }
            help    "A global scale factor applied to points."
            range   { 0! 10 }
            export  none
        }
        parm {
            name    "ar_step_size"
            label   "Volume Step Size"
            type    float
            default { "0" }
            disablewhen "{ ar_mode != sphere }"
            help    "When rendered as spheres and ar_volume_step_size is set to a value above 0, and the points or particles will be rendered as volumes."
            range   { 0 10 }
            export  none
        }
        parm {
        name    "ar_aspect"
        label   "Aspect"
        type    log
        default { "1" }
        help    "The aspect ratio for quads. This property can be overrriden per point by setting the \"ar_aspect\" or \"spritescale\" attributes on the geometry."
        disablewhen "{ ar_mode != quad }"
        range   { 0.1 10 }
        export  none
        }
        parm {
        name    "ar_rotation"
        label   "Rotation"
        type    angle
        default { "0" }
        help    "The rotation angle in degrees for quads. This property can be overrriden per point by setting the \"ar_rotation\" or the \"spriterot\" attributes on the geometry."
        disablewhen "{ ar_mode != quad }"
        range   { -180 180 }
        export  none
        }
    }

    group {
        name    "folder_curves"
        label   "Curves"

        parm {
        name    "ar_curves_basis"
        label   "Basis"
        type    string
        default { "auto" }
        help    "The curves basis to interpret the knots of the input curves or open polygons. When set to \"Automatic\", the basis will attempt to match the closest equivalent in Arnold, ie. linear for open polygons, Bezier for Bezier curves and B-spline for NURBS."
        menu    {
            "bezier"    "Bezier"
            "b-spline"  "B-Spline"
            "catmull-rom"   "Catmull-Rom"
            "linear"    "Linear"
            "auto"      "Automatic"
        }
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Curves" }
        }
        parm {
        name    "ar_curves_mode"
        label   "Mode"
        type    string
        default { "ribbon" }
        help    "- Ribbon: This mode is recommended for fine geometry such as realistic hair, fur or fields of grass. These curves are rendered as camera-facing flat ribbons. For secondary and shadow rays, they face the incoming ray direction. This mode doesn't look so good for very wide hairs or dramatic zoom-ins because of the flat appearance. This mode works best with a proper hair shader (perhaps based on a Kay-Kajiya or Marschner specular model).\\n\\n- Thick: This mode resembles spaghetti. It has a circular cross section, and a normal vector that varies across the width of the hair. Thick hairs look great when zoomed in, and are specially useful for effects work, but their varying normals make them more difficult to antialias when they are small. You can use any shader with this rendering mode, including lambert, phong, etc.\\n\\n- Oriented: This mode is similar to the ribbons mode, but you can set the ribbon orientation for each knot with an \"ar_orientations\" vector attribute representing the direction of the normal of the ribbon. This mode can be useful to render grass strands for example."
        menu    {
            "ribbon"    "Ribbon"
            "thick" "Thick"
            "oriented"  "Oriented      "
        }
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Curves" }
        }
//        parm {
//        name    "ar_max_subdivs"
//        label   "Max. Subdivisions"
//        type    integer
//        default { "6" }
//        range   { 0! 7! }
//        export  none
//        }
    }
    
    group {
	name	"folder_tessellation"
	label	"Tessellation"

	parm {
	    name	"ar_tessellation_enable"
	    label	"Tessellate Primitives"
	    type	toggle
	    default	{ "1" }
	    help	"Tessellate Houdini primitives such as NURBS, Bezier meshes, circles, tubes or spheres prior to sending to Arnold."
	    disablewhen	"{ ar_tessellation_use_rop == 1 }"
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Tessellation" }
	}
	parm {
	    name	"ar_tessellation_style"
	    label	"Tessellation Style"
	    type	string
	    default	{ "lod" }
	    help	"Specifies the conversion style for the geometry. The default is\"Level of Detail\". Can be one of the following:\\n- Level of Detail: Tessellate geometry using the level of detail settings.\\n- Divisions: Tessellate geometry based on the number of divisions settings."
	    disablewhen	"{ ar_tessellation_enable == 0 }"
	    invisible
	    menu	{
		"lod"	"Level of Detail"
		"div"	"Divisions"
	    }
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Tessellation" }
	}
	parm {
	    name	"ar_tessellation_ulod"
	    label	"U Level of Detail"
	    type	float
	    default	{ "1" }
	    help	"Specifies the level of detail for U subdivisions of the surface being converted. Applicable only when conversion method is set to Level of Detail. Defaults to 1.0."
	    disablewhen	"{ ar_tessellation_enable == 0 }"
	    hidewhen	"{ ar_tessellation_style != lod }"
	    range	{ 0! 10 }
	    export	none
	    parmtag	{ "spare_category" "Tessellation" }
	}
	parm {
	    name	"ar_tessellation_vlod"
	    label	"V Level of Detail"
	    type	float
	    default	{ "1" }
	    help	"Specifies the level of detail for V subdivisions of the surface being converted. Applicable only when conversion method is set to Level of Detail. Defaults to 1.0."
	    disablewhen	"{ ar_tessellation_enable == 0 }"
	    hidewhen	"{ ar_tessellation_style != lod }"
	    range	{ 0! 10 }
	    export	none
	    parmtag	{ "spare_category" "Tessellation" }
	}
	parm {
	    name	"ar_tessellation_trimlod"
	    label	"Trim Level of Detail"
	    type	float
	    default	{ "1" }
	    help	"Specifies the level of detail for trim curves of the surface being converted. Applicable only when conversion method is set to Level of Detail. Defaults to 1.0."
	    disablewhen	"{ ar_tessellation_enable == 0 }"
	    hidewhen	"{ ar_tessellation_style != lod }"
	    range	{ 0! 10 }
	    export	none
	    parmtag	{ "spare_category" "Tessellation" }
	}
//	parm {
//	    name	"ar_tessellation_udiv"
//	    label	"U Divisions"
//	    type	integer
//	    default	{ "10" }
//	    help	"Specifies the number of U subdivisions of the surface being converted. Applicable only when conversion method is set to Level of Detail. Defaults to 1.0."
//	    disablewhen	"{ ar_tessellation_enable == 0 }"
//	    hidewhen	"{ ar_tessellation_style != div }"
//	    range	{ 0! 50 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_vdiv"
//	    label	"V Divisions"
//	    type	integer
//	    default	{ "10" }
//	    help	"Specifies the number of V subdivisions of the surface being converted. Applicable only when conversion method is set to Level of Detail. Defaults to 1.0."
//	    disablewhen	"{ ar_tessellation_enable == 0 }"
//	    hidewhen	"{ ar_tessellation_style != div }"
//	    range	{ 0! 50 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_trimdiv"
//	    label	"Trim Divisions"
//	    type	integer
//	    default	{ "10" }
//	    help	"Specifies the number of subdivisions for trim curves of the surface being converted. Applicable only when conversion method is set to Level of Detail. Defaults to 1.0."
//	    disablewhen	"{ ar_tessellation_enable == 0 }"
//	    hidewhen	"{ ar_tessellation_style != div }"
//	    range	{ 0! 50 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_polysides_enable"
//	    label	"Enable Convexing"
//	    type	toggle
//	    nolabel
//	    joinnext
//	    default	{ "1" }
//	    help	"Enables convexing polygons to a number of sides."
//	    disablewhen	"{ ar_tessellation_enable == 0 }"
//	    range	{ 0 1 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_polysides"
//	    label	"Convex Sides"
//	    type	integer
//	    default	{ "3" }
//	    help	"An integer that specifies the number of sides to convex."
//	    disablewhen	"{ ar_tessellation_enable == 0 } { ar_tessellation_polysides_enable == 0 }"
//	    range	{ 3! 10 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_metastyle_enable"
//	    label	"Enable Metaballs Tessellation Style"
//	    type	toggle
//	    nolabel
//	    joinnext
//	    default	{ "1" }
//	    help	"Enable secondary method for converting metaballs."
//	    disablewhen	"{ ar_tessellation_enable == 0 }"
//	    range	{ 0 1 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_metastyle"
//	    label	"Metaballs Style"
//	    type	string
//	    joinnext
//	    default	{ "lod" }
//	    help	"Specifies the style to convert metaballs with. This may be different from the main conversion style, and can be one of the following values:\\n- Level of Detail: Use the level of detail conversion method.\\n- Divisions: Use a fixed number of subidivisions to convert metaballs.\\n- Steps: This option will create slice planes at equally spaced steps.\\n- Cross Sections: This option will generate cross sectional polygons. The number of cross sections determines how many cross sections will be built along the axis specified. The maximum depth determines the accuracy of the cross sections."
//	    disablewhen	"{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
//	    menu	{
//		"lod"	"Level of Detail"
//		"div"	"Divisions"
//		"step"	"Steps"
//		"xsect"	"Cross Sections"
//	    }
//	    range	{ 0 1 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_metaadjust"
//	    label	"Align Bounding Box                    "
//	    type	toggle
//	    default	{ "1" }
//	    help	"If true, the bounding box will be aligned so that the slicing planes will not change unless the divisions also change. Defaults to true."
//	    disablewhen	"{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
//	    range	{ 0 1 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_metalod"
//	    label	"Metaballs LOD"
//	    type	float
//	    joinnext
//	    default	{ "1" }
//	    help	"Specifies a single LOD value to control tessellation density. Valid only when metaball conversion style is Level of Detail. Defaults to 1.0."
//	    disablewhen	"{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
//	    hidewhen	"{ ar_tessellation_metastyle != lod }"
//	    range	{ 0 10 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_metacluster"
//	    label	"Enable Clustering"
//	    type	toggle
//	    default	{ "0" }
//	    help	"Enables clustering if true. Valid only when metaball conversion style is lod. Defaults to false."
//	    disablewhen	"{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
//	    hidewhen	"{ ar_tessellation_metastyle != lod }"
//	    range	{ 0 1 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_metadiv"
//	    label	"Metaballs Divisions"
//	    type	integer
//	    size	3
//	    default	{ "10" "10" "10" }
//	    help	"Specifies the number of x, y and z divisions for the bounding box of the geometry. Valid only when metaball conversion style is Divisions. This should be a vector of three integers. Defaults to {10, 10, 10}."
//	    disablewhen	"{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
//	    hidewhen	"{ ar_tessellation_metastyle != div }"
//	    range	{ 0 10 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_metastep"
//	    label	"Metaballs Step Size"
//	    type	float
//	    size	3
//	    default	{ "0.1" "0.1" "0.1" }
//	    help	"Specifies x,y and z step sizes for subdivisions. Valid only when metaball conversion style is Steps. This should be a vector of three floating-point numbers. Defaults to {0.1, 0.1, 0.1}."
//	    disablewhen	"{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
//	    hidewhen	"{ ar_tessellation_metastyle != step }"
//	    range	{ 0 10 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_metasections"
//	    label	"Cross Sections"
//	    type	integer
//	    joinnext
//	    default	{ "20" }
//	    help	"Number of cross-sections to build when subdividing. Valid only when metaball conversion style is Cross Section. Defaults to 20"
//	    disablewhen	"{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
//	    hidewhen	"{ ar_tessellation_metastyle != xsect }"
//	    range	{ 0! 100 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_metaaxis"
//	    label	"   Axis"
//	    type	integer
//	    default	{ "2" }
//	    help	"Axis along which cross-section planes will be built. Valid only when metaball conversion style is xsect. This value is an integer between 0 and 2 inclusive. Defaults to 2, that is, the Z axis."
//	    disablewhen	"{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
//	    hidewhen	"{ ar_tessellation_metastyle != xsect }"
//	    menu	{
//		"0"	"X"
//		"1"	"Y"
//		"2"	"Z"
//	    }
//	    range	{ 0! 2! }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
//	parm {
//	    name	"ar_tessellation_metamaxdepth"
//	    label	"Maximum Depth"
//	    type	integer
//	    default	{ "5" }
//	    help	"Specifies the maximum depth when building cross-sections. This determines the accuracy of the conversion. Defaults to 5."
//	    disablewhen	"{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
//	    hidewhen	"{ ar_tessellation_metastyle != xsect }"
//	    range	{ 0! 20 }
//	    export	none
//	    parmtag	{ "spare_category" "Tessellation" }
//	}
    }
    }
    
    group {
    name    "folder_attributes"
    label   "Attributes"

    parm {
        name    "ar_attributes_detail"
        label   "Detail Attributes"
        type    string
        default { "*" }
        help    "The list of details attributes to be exported as user data for Arnold. As user data is costly in memory, nothing is exported by default. If this field contains a wildcard character (*), all available attributes will be exported."
        menutoggle  {
        [ "__import__('htoa').properties.detailAttributeMenu()" ]
        language    python
        }
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Attributes" }
    }
    parm {
        name    "ar_attributes_primitive"
        label   "Primitive Attributes"
        type    string
        default { "*" }
        help    "The list of primitive attributes to be exported as user data for Arnold. As user data is costly in memory, nothing is exported by default. If this field contains a wildcard character (*), all available attributes will be exported."
        menutoggle  {
        [ "__import__('htoa').properties.primitiveAttributeMenu()" ]
        language    python
        }
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Attributes" }
    }
    parm {
        name    "ar_attributes_point"
        label   "Point Attributes"
        type    string
        default { "*" }
        help    "The list of point attributes to be exported as user data for Arnold. As user data is costly in memory, nothing is exported by default. If this field contains a wildcard character (*), all available attributes will be exported."
        menutoggle  {
        [ "__import__('htoa').properties.pointAttributeMenu()" ]
        language    python
        }
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Attributes" }
    }
    parm {
        name    "ar_attributes_vertex"
        label   "Vertex Attributes"
        type    string
        default { "*" }
        help    "The list of vertex attributes to be exported as user data for Arnold. As user data is costly in memory, nothing is exported by default. If this field contains a wildcard character (*), all available attributes will be exported."
        menutoggle  {
        [ "__import__('htoa').properties.vertexAttributeMenu()" ]
        language    python
        }
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Attributes" }
    }
    parm {
        name    "ar_merge_vertex_indices"
        label   "Merge Vertex Indices"
        type    toggle
        default { "0" }
        help    "Enable merging of the indices and data of coincident and identical vertex attribute values (UVs, normals, vertex user data). This allows the proper interpolation of vertex attributes when subdividing, and yields more compact render scenes in memory and on disk, at the cost of a slower export."
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Attributes" }
    }
    }

    group {
	name	"folder_motion_blur"
	label	"Motion Blur"

	parm {
	    name	"ar_mb_xform_keys_override"
	    label	"Transform Keys Override"
	    type	toggle
	    nolabel
	    joinnext
	    default	{ "0" }
	    help	"Override the ROP settings for Transform Keys."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Motion Blur" }
	}
	parm {
	    name	"ar_mb_xform_keys"
	    label	"Transform Keys"
	    type	integer
	    default	{ "2" }
	    help	"Number of motion keys for matrix transformation. Transformation motion blur is calculated based on a linear interpolation of an object transform matrix, between successive motion keys. Increasing this value will add extra steps, which can improve the blurred result, especially for rotating objects. The default is 2, which results in straight lines of blur between shutter start and shutter end."
	    disablewhen	"{ ar_mb_xform_keys_override == 0 }"
	    range	{ 1! 20 }
	    export	none
	    parmtag	{ "spare_category" "Motion Blur" }
	}
	parm {
	    name	"ar_mb_dform_keys_override"
	    label	"Deform Keys Override"
	    type	toggle
	    nolabel
	    joinnext
	    default	{ "0" }
	    help	"Override the ROP settings for Transform Keys."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Motion Blur" }
	}
	parm {
	    name	"ar_mb_dform_keys"
	    label	"Deform Keys"
	    type	integer
	    default	{ "2" }
	    help	"Number of motion keys for object points. Just like with transformation motion keys, increasing this value allows curved motion paths to be rendered more accurately, at the expense of using more memory."
	    disablewhen	"{ ar_mb_dform_keys_override == 0 } { ar_mb_velocity_enable == 1 ar_mb_acceleration_enable != 1 }"
	    range	{ 1! 20 }
	    export	none
	    parmtag	{ "spare_category" "Motion Blur" }
	}
	parm {
	    name	"ar_mb_velocity_enable"
	    label	"Velocity Blur Enable"
	    type	toggle
	    nolabel
	    joinnext
	    default	{ "0" }
	    help	"Deformation blur will be computed from the \"v\" point attribute."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Motion Blur" }
	}
	parm {
	    name	"ar_mb_velocity_attribute"
	    label	"Velocity Blur"
	    type	string
	    default	{ "v" }
	    help    "The velocity point attribute to use for velocity blur. The Houdini convention is 'v'."
	    disablewhen	"{ ar_mb_velocity_enable == 0 }"
        menureplace  {
        [ "geometry = hou.pwd().renderNode().geometry()" ]
        [ "if not geometry:" ]
        [ "    return []" ]
        [ "menu_items = []" ]
        [ "for attr in geometry.pointAttribs():" ]
        [ "    if not attr.name() in ('P', 'Pw'):" ]
        [ "        menu_items += [attr.name(), '%s\\t  %s[%i]' % (attr.name(), attr.dataType().name().lower(), attr.size())]" ]
        [ "return menu_items" ]
        language    python
        }
	    range	{ 0 1 }
	    export	none
	}
	parm {
	    name	"ar_mb_acceleration_enable"
	    label	"Acceleration Blur Enable"
	    type	toggle
	    nolabel
	    joinnext
	    default	{ "0" }
	    disablewhen	"{ ar_mb_velocity_enable == 0 }"
	    range	{ 0 1 }
	    export	none
	}
	parm {
	    name	"ar_mb_acceleration_attribute"
	    label	"Acceleration Blur"
	    type	string
	    default	{ "force" }
        help    "The acceleration point attribute to use for acceleration blur. The Houdini convention is 'force' or 'accel'. If you use use 'force' ensure you divide by the mass."
	    disablewhen	"{ ar_mb_velocity_enable == 0 } { ar_mb_acceleration_enable == 0 }"
        menureplace  {
        [ "geometry = hou.pwd().renderNode().geometry()" ]
        [ "if not geometry:" ]
        [ "    return []" ]
        [ "menu_items = []" ]
        [ "for attr in geometry.pointAttribs():" ]
        [ "    if not attr.name() in ('P', 'Pw'):" ]
        [ "        menu_items += [attr.name(), '%s\\t  %s[%i]' % (attr.name(), attr.dataType().name().lower(), attr.size())]" ]
        [ "return menu_items" ]
        language    python
        }
	    range	{ 0 1 }
	    export	none
	}

// These parameters are commented because it is not possible to override the
// geometry shutter per object as of Arnold 4.1.0.0. See tickets #34 and #210.
// 
//    parm {
//        name    "ar_mb_shutter"
//        label   "Geometry Shutter"
//        type    ordinal
//        default { "rop" }
//        menu    {
//        "rop"   "Use ROP Shutter"
//        "camera"   "Use Camera Shutter"
//        "start" "Start On Frame"
//        "center"    "Center On Frame"
//        "end"   "End On Frame"
//        "custom"    "Custom Shutter"
//        }
//        help    "Specifies at which point in the frame the shutter should open which allows you to change the motion blur trails. The Shutter position offsets the motion blur within the image."
//        range   { 0 1 }
//        export  none
//        parmtag { "script_callback_language" "python" }
//        parmtag { "script_callback" "" }
//    }
//    parm {
//        name    "ar_mb_shutter_length"
//        label   "Shutter Length"
//        type    float
//        default { "0.5" }
//        help    "You can use this attribute to tweak the size and length of the motion blur trails. It simulates the effect of camera shutter speed."
//        hidewhen    "{ ar_mb_shutter == custom } { ar_mb_shutter == rop } { ar_mb_shutter == camera }"
//        range   { 0 1 }
//        export  none
//    }
//    parm {
//        name    "ar_mb_shutter_range"
//        label   "Shutter Start/End"
//        type    vector2
//        size    2
//        default { "-0.25" "0.25" }
//        help    "Specifically sets the start and end times of the shutter. Can be used to create custom motion blur effects."
//        hidewhen    "{ ar_mb_shutter != custom }"
//        range   { -1 1 }
//        export  none
//    }
    }

    group {
	name	"folder_visibility"
	label	"Visibility"

	parm {
	    name	"ar_visibility_camera"
	    label	"Visible to Camera Rays"
	    type	toggle
	    default { "1" }
	    help	"Toggle object visibility for camera rays (i.e. primary or view rays)."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Visibility" }
	}
	parm {
	    name	"ar_visibility_shadow"
	    label	"Visible to Shadow Rays"
	    type	toggle
	    default	{ "1" }
	    help	"Toggle object visibility for shadow rays fired in the direct lighting calculations."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Visibility" }
	}
	parm {
	    name	"ar_visibility_reflection"
	    label	"Visible to Reflected Rays"
	    type	toggle
	    default	{ "1" }
	    help	"Toggle object visibility for mirror reflection rays."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Visibility" }
	}
	parm {
	    name	"ar_visibility_refraction"
	    label	"Visible to Refracted Rays"
	    type	toggle
	    default	{ "1" }
	    help	"Toggle object visibility for refraction rays."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Visibility" }
	}
	parm {
	    name	"ar_visibility_diffuse"
	    label	"Visible to Diffuse Rays"
	    type	toggle
	    default	{ "1" }
	    help	"Toggle object visibility for indirect diffuse rays (i.e. global illumination, hemi, or GI rays)."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Visibility" }
	}
	parm {
	    name	"ar_visibility_glossy"
	    label	"Visible to Glossy Rays"
	    type	toggle
	    default	{ "1" }
	    help	"Toggle object visibility for indirect specular rays (i.e. glossy reflection rays)."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Visibility" }
	}
	parm {
	    name	"ar_receive_shadows"
	    label	"Receive Shadows"
	    type	toggle
	    default	{ "1" }
	    help	"Enable/disable received shadows over the object."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Visibility" }
	}
	parm {
	    name	"ar_self_shadows"
	    label	"Self Shadows"
	    type	toggle
	    default	{ "1" }
	    help	"Enable/disable self-shadowing over the object."
	    disablewhen    "{ ar_receive_shadows == 0 }"
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Visibility" }
	}
	parm {
	    name	"ar_opaque"
	    label	"Opaque"
	    type	toggle
	    default	{ "1" }
	    help	"By default, Arnold will assume that objects are opaque, which lets the renderer take certain shortcuts and optimizations for maximum ray tracing speed. When this option is unchecked, the object is assumed as \"possibly transparent\", and Arnold will perform extra computations to support transparency and transparent shadows, according to the shader's opacity settings."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Visibility" }
	}
    parm {
        name    "ar_matte"
        label   "Matte"
        type    toggle
        default { "0" }
        help    "Output black and zero alpha for camera rays to create a holdout."
        range   { 0 1 }
        export  none
        parmtag { "spare_category" "Visibility" }
    }
	parm {
	    name	"ar_use_light_group"
	    label	"Use Light Group"
	    type	toggle
	    invisible
	    nolabel
	    joinnext
	    default	{ "0" }
	    range	{ 0 1 }
	    export	none
	}
	parm {
	    name	"ar_light_group"
	    label	"Light Group"
	    type	oplist
        invisible
	    default	{ "" }
	    disablewhen	"{ ar_use_light_group == 0 }"
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "oprelative" "/" }
	    parmtag	{ "opfilter" "!!OBJ/LIGHT!!" }
	}
	parm {
	    name	"ar_use_shadow_group"
	    label	"Use Shadow Group"
	    type	toggle
        invisible
	    nolabel
	    joinnext
	    default	{ "0" }
	    range	{ 0 1 }
	    export	none
	}
	parm {
	    name	"ar_shadow_group"
	    label	"Shadow Group"
	    type	oplist
        invisible
	    default	{ "" }
	    disablewhen	"{ ar_use_shadow_group == 0 }"
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "oprelative" "/" }
	    parmtag	{ "opfilter" "!!OBJ/LIGHT!!" }
	}
	parm {
	    name	"ar_trace_sets"
	    label	"Trace Sets"
	    type	string
	    default	{ "" }
	    menutoggle	{
	    [ "def traverse(node, my_set):" ]
        [ "    for child in node.children():" ]
        [ "        if child.type().category() == hou.objNodeTypeCategory() and child.parm('ar_trace_sets'):" ]
        [ "            setnames = child.parm('ar_trace_sets').evalAsString()" ]
        [ "            if setnames:" ]
        [ "                my_set.update(setnames.split())" ]
        [ "        traverse(child, my_set)" ]
        [ "" ]
        [ "tracesets = set()" ]
        [ "traverse(hou.node('/'), tracesets)" ]
        [ "tracesets = list(tracesets)" ]
        [ "tracesets.sort()" ]
        [ "" ]
        [ "return [x for y in zip(tracesets, tracesets) for x in y]" ]
        language    python
	    }
	    range	{ 0 1 }
	    export	none
	}
    parm {
    name    "ar_sss_setname"
    label   "SSS Set"
    type    string
    default { "" }
    menureplace {
        [ "def traverse(node, my_set):" ]
        [ "    for child in node.children():" ]
        [ "        if child.type().category() == hou.objNodeTypeCategory() and child.parm('ar_sss_setname'):" ]
        [ "            setname = child.parm('ar_sss_setname').evalAsString()" ]
        [ "            if setname:" ]
        [ "                my_set.update([setname])" ]
        [ "        traverse(child, my_set)" ]
        [ "" ]
        [ "sss_names = set()" ]
        [ "traverse(hou.node('/'), sss_names)" ]
        [ "sss_names = list(sss_names)" ]
        [ "sss_names.sort()" ]
        [ "" ]
        [ "return [x for y in zip(sss_names, sss_names) for x in y]" ]        language    python
    }
    help "Use this parameter to tag multiple objects as belonging to the same SSS set so that illumination will blur across object boundaries. A common use case might be blurring between teeth and gum geometry. This feature is only available when using raytraced SSS."
    range   { 0 1 }
    export  none
    }
    }

    group {
	name	"folder_normals"
	label	"Normals"

	parm {
	    name	"ar_smoothing"
	    label	"Smoothing"
	    type	toggle
	    default	{ "1" }
	    help	"Smooth/Flat normals."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Render" }
	}
	parm {
	    name	"ar_invert_normals"
	    label	"Invert Normals"
	    type	toggle
	    default	{ "0" }
	    help	"Invert normals"
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Render" }
	}
	parm {
	    name	"ar_sidedness_camera"
	    label	"Double-sided for Camera"
	    type	toggle
	    default	{ "1" }
	    help	"Toggle object double-sidedness for camera rays (i.e. primary or view rays)."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Sidedness" }
	}
	parm {
	    name	"ar_sidedness_shadow"
	    label	"Double-sided for Shadow"
	    type	toggle
	    default	{ "1" }
	    help	"Toggle object double-sidedness for shadow rays fired in the direct lighting calculations."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Sidedness" }
	}
	parm {
	    name	"ar_sidedness_reflection"
	    label	"Double-sided for Reflection"
	    type	toggle
	    default	{ "1" }
	    help	"Toggle object double-sidedness for mirror reflection rays."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Sidedness" }
	}
	parm {
	    name	"ar_sidedness_refraction"
	    label	"Double-sided for Refraction"
	    type	toggle
	    default	{ "1" }
	    help	"Toggle object double-sidedness for refraction rays."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Sidedness" }
	}
	parm {
	    name	"ar_sidedness_diffuse"
	    label	"Double-sided for Diffuse"
	    type	toggle
	    default	{ "1" }
	    help	"Toggle object double-sidedness for indirect diffuse rays (i.e. global illumination, hemi, or GI rays)."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Sidedness" }
	}
	parm {
	    name	"ar_sidedness_glossy"
	    label	"Double-sided for Glossy"
	    type	toggle
	    default	{ "1" }
	    help	"Toggle object double-sidedness for indirect specular rays (i.e. glossy reflection rays)."
	    range	{ 0 1 }
	    export	none
	    parmtag	{ "spare_category" "Sidedness" }
	}
    }


}