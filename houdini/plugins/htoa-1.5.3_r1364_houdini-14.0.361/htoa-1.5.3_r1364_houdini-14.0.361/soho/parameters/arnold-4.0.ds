// $Id: arnold-4.0.ds 1354 2015-06-12 10:22:12Z kik $
// Houdini Parameters for Arnold 4.0

#include "$HH/soho/parameters/CommonMacros.ds"

// Output image formats
#define AR_IMAGE_FORMATS \
            "exr"       "OpenEXR" \
            "deepexr"   "OpenEXR - Deep" \
            "tiff"      "TIFF" \
            "png"       "PNG" \
            "jpeg"      "JPEG" \

// Image format menu for beauty
#define AR_IMAGE_FORMAT_MENU \
        menu { \
            AR_IMAGE_FORMATS \
        }

// Image format menu for beauty
#define AR_AOV_IMAGE_FORMAT_MENU \
        menu { \
            "beauty"      "Same as Beauty  " \
            AR_IMAGE_FORMATS \
        }

// Pixel filters
#define AR_PIXEL_FILTERS \
            "blackman_harris_filter" "Blackman-Harris" \
            "box_filter"             "Box" \
            "catrom2d_filter"        "Catmull-Rom 2D" \
            "catrom_filter"          "Catmull-Rom" \
            "closest_filter"         "Closest" \
            "cone_filter"            "Cone" \
            "cook_filter"            "Cook" \
            "cubic_filter"           "Cubic" \
            "disk_filter"            "Disk" \
            "farthest_filter"        "Farthest" \
            "gaussian_filter"        "Gaussian" \
            "heatmap_filter"         "Heatmap" \
            "mitnet_filter"          "Mitchell-Netravali" \
            "sinc_filter"            "Sinc" \
            "triangle_filter"        "Triangle" \
            "variance_filter"        "Variance" \
            "video_filter"           "Video" \
            
// Pixel filter menu for beauty
#define AR_PIXEL_FILTER_MENU   \
        menu { \
            AR_PIXEL_FILTERS \
        }

// Pixel filter menu for AOVs
#define AR_AOV_PIXEL_FILTER_MENU       \
        menu { \
            "beauty"                 "Same as Beauty  " \
            AR_PIXEL_FILTERS \
        }

// Standard AOV labels
#define AR_LABEL_MENU    \
        menureplace { \
            "RGBA"               "Beauty\tRGBA" \
            "A"                  "Alpha\tA" \
            "Z"                  "Depth\tZ" \
            "P"                  "Point\tP" \
            "N"                  "Normal\tN" \
            "ID"                 "Object Labels\tID" \
            "opacity"            "Opacity\topacity" \
            "cputime"            "CPU Time\tcputime" \
            "texturetime"        "Texture Time\ttexturetime" \
            "raycount"           "Ray Count\traycount" \
            "emission"           "Emission\temission" \
            "direct_diffuse"     "Direct Diffuse\tdirect_diffuse" \
            "direct_specular"    "Direct Specular\tdirect_specular" \
            "indirect_diffuse"   "Indirect Diffuse\tindirect_diffuse" \
            "indirect_specular"  "Indirect Specular\tindirect_specular" \
            "reflection"         "Reflection\treflection" \
            "refraction"         "Refraction\trefraction" \
            "refraction_opacity" "Refraction Opacity\trefraction_opacity" \
            "sss"                "Subsurface Scattering\tsss" \
            "volume"             "Volume\tvolume" \
            "volume_opacity"     "Volume Opacity\tvolume_opacity" \
        }

// AOV type menu
#define AR_TYPE_MENU   \
        menu { \
            "RGB"      "RGB" \
            "RGBA"     "RGBA" \
            "BOOL"     "Boolean" \
            "INT"      "Integer" \
            "FLOAT"    "Float" \
            "VECTOR"   "Vector" \
            "POINT"    "Point" \
            "POINT2"   "Point (2D)" \
            "POINTER"  "Pointer" \
        }
        
//////////////////////////////////////////////////////////////////////////////
// Arnold properties
{
    name    arnold4.0
    label   "Arnold 4.0"
    parmtag { spare_opfilter "!!SHOP/PROPERTIES!!" }

#include "$HH/soho/parameters/CommonControl.ds"
#include "$HH/soho/parameters/CommonView.ds"
#include "$HH/soho/parameters/CommonObject.ds"
#include "$HH/soho/parameters/Instance.ds"

    //////////////////////////////////////////////////////////////////////////
    // Output
    //
    parm {
        SOHO_FILE(ar_picture, "Output Picture", "Output", "ip")
        parmtag { filechooser_mode "write" }
        menureplace {
            [ "echo `pythonexprs(\"__import__('toolutils').parseDialogScriptMenu('FBrender')\")`" ]
            [ ]
        }
    }
    parm {
        SOHO_STRING(ar_picture_format, "Image Format", "Output", "exr")
        AR_IMAGE_FORMAT_MENU
        joinnext
        help "Output image file format."
        parmtag { "script_callback_language" "python" }
        parmtag { "script_callback" "kwargs['node'].parm('ar_exr_metadata').hide(kwargs['script_value'] != 'exr')" }

    }
    parm {
        SOHO_INT(ar_picture_tiling, "                Tiling", "Output", 0)
        menu {
            0 "Scanline  "
            1 "Tiled"
        }
        hidewhen "{ ar_picture_format != exr ar_picture_format != deepexr ar_picture_format != tiff }"
        help "Allows to save the image in scanline or tiled mode. It seems Scanline works better with composition packages like Nuke or Fusion."
    }
    parm {
        SOHO_STRING(ar_exr_compression, "Compression", "Output", "zip")
        menu {
            "none"  "None                     "
            "rle"   "Run Length Encoding (RLE)"
            "zips"  "Zip (per scanline)"
            "zip"   "Zip (16 scanline blocks)"
            "piz"   "PIZ"
            "pxr24" "PXR24"
            "b44"   "B44"
            "b44a"  "B44A"
            "dwaa"  "DWAA"
            "dwab"  "DWAB"
        }
        hidewhen "{ ar_picture_format != exr }"
        help "Specifies the compression mode of the EXR file:\n\n- None: Disables all compression.\n\n- Run Length Encoding (RLE): This is a basic form of compression that is comparable to that used by standard Targa files.\n\n- Zip (per scanline): Zip style compression applied to individual scanlines.\n\n- Zip (16 scanline blocks): Zip style compression applied to blocks of 16 scanlines at time. This tends to be the most effective style of compression to use with rendered images that do not have film grain applied.\n\n- PIZ: This uses a new combined wavelet / Huffman compression. This form of compression is quite effective when dealing with grainy images, and will often surpass any of the other options under grainy conditions.\n\n- PXR24: This form of compression from Pixar converts data to 24 bit then uses Zip compression. It is lossless for half and 32bit integer data and slightly lossy for 32bit float data.\n\n- B44: This form of compression is lossy for half data and stores 32bit data uncompressed.\n\n- B44A: An extension to B44 where areas of flat color are further compressed. Regular B44 compresses uniformly regardless of image content.\n\n- DWAA: JPEG-like lossy compression format contributed by DreamWorks Animation. Compresses 32 scanlines together.\n\n- DWAB: Same as DWAA, but compresses blocks of 256 scanlines."
    }
    parm {
        SOHO_TOGGLE(ar_exr_half_precision, "Half Precision", "Output", 0)
        hidewhen "{ ar_picture_format != exr }"
        help "Store pixels as half-floats instead of floats."
    }
    parm {
        SOHO_TOGGLE(ar_exr_preserve_layer_name, "Preserve Layer Name", "Output", 0)
        hidewhen "{ ar_picture_format != exr }"
        help "If checked, will store the AOV in a layer different with the name of the AOV, and not the RGB."
    }
    parm {
        SOHO_TOGGLE(ar_exr_autocrop, "Autocrop", "Output", 0)
        hidewhen "{ ar_picture_format != exr }"
        disablewhen "{ ar_picture_tiling != 0 }"
        help "Automatically crop uniform borders."
    }
    parm {
        SOHO_TOGGLE(ar_deepexr_subpixel_merge, "Merge Subpixel Samples", "Output", 1)
        hidewhen "{ ar_picture_format != deepexr }"
        help "Nearby subpixel samples will be merged."
    }
    parm {
        SOHO_FLOAT(ar_deepexr_beauty_tolerance, "Beauty Tolerance", "Output", 0.01)
        hidewhen "{ ar_picture_format != deepexr }"
        range { 0! 1 }
        logarithmic
        disablewhen "{ ar_deepexr_subpixel_merge == 0 }"
        help "Beauty tolerance over which samples will not be merged together."
    }
    parm {
        SOHO_FLOAT(ar_deepexr_alpha_tolerance, "Alpha Tolerance", "Output", 0.01)
        hidewhen "{ ar_picture_format != deepexr }"
        range { 0! 1 }
        logarithmic
        disablewhen "{ ar_deepexr_subpixel_merge == 0 }"
        help "Alpha tolerance over which samples will not be merged together."
    }
    parm {
        SOHO_FLOAT(ar_deepexr_depth_tolerance, "Depth Tolerance", "Output", 0.01)
        hidewhen "{ ar_picture_format != deepexr }"
        range { 0! 10 }
        logarithmic
        disablewhen "{ ar_deepexr_subpixel_merge == 0 }"
        help "Depth tolerance over which samples will not be merged together."
    }
    parm {
        SOHO_TOGGLE(ar_deepexr_beauty_half_precision, "Half Precision for Beauty", "Output", 0)
        hidewhen "{ ar_picture_format != deepexr }"
        help "Store beauty layer as half-floats instead of floats."
    }
    parm {
        SOHO_TOGGLE(ar_deepexr_alpha_half_precision, "Half Precision for Alpha", "Output", 0)
        hidewhen "{ ar_picture_format != deepexr }"
        help "Store alpha layer as half-floats instead of floats."
    }
    parm {
        SOHO_TOGGLE(ar_deepexr_depth_half_precision, "Half Precision for Depth", "Output", 0)
        hidewhen "{ ar_picture_format != deepexr }"
        help "Store depth layer as half-floats instead of floats."
    }
    parm {
        SOHO_TOGGLE(ar_deepexr_use_RGB_opacity, "RGB Opacity", "Output", 0)
        hidewhen "{ ar_picture_format != deepexr }"
        help "Write out RGB opacity, rather than just alpha. Nuke can read these images but cannot display them."
    }
    parm {
        SOHO_TOGGLE(ar_deepexr_enable_filtering, "Filter Beauty", "Output", 1)
        hidewhen "{ ar_picture_format != deepexr }"
        help "If set to false disable any filtering operation on this layer's raw data -- useful for normals or ID layers."
    }
    parm {
        SOHO_TOGGLE(ar_picture_append, "Append", "Output", 0)
        hidewhen "{ ar_picture_format != exr ar_picture_format != tiff }"
        disablewhen "{ ar_picture_tiling != 1 }"
        help "Append to existing tiles when re-rendering the same image."
    }
    
    multiparm {
    name    "ar_exr_metadata"
    label   "Metadata"
    parmtag { spare_category        "Output" }

    parm {
        name    "ar_exr_metadata_key#"
        label   "Key"
        type    string
        joinnext
        default { "metadata#" }
        range   { 0 1 }
        help "Metadata key name."
        export  none
    }
    parm {
        name    "ar_exr_metadata_type#"
        label   "   Type"
        type    ordinal
        default { "4" }
        menu    {
        "int"   "Integer"
        "float" "Float"
        "point2"    "Point2"
        "matrix"  "Matrix"
        "string"    "String"
        }
        range   { 0 1 }
        help "Metadata type."
        export  none
    }
    parm {
        name    "ar_exr_metadata_int_value#"
        label   "Value"
        type    integer
        default { "0" }
        hidewhen    "{ ar_exr_metadata_type# != int }"
        range   { 0 10 }
        help "Metadata integer value."
        export  none
    }
    parm {
        name    "ar_exr_metadata_float_value#"
        label   "Value"
        type    float
        default { "0" }
        hidewhen    "{ ar_exr_metadata_type# != float }"
        range   { 0 10 }
        help "Metadata float value."
        export  none
    }
    parm {
        name    "ar_exr_metadata_point2_value#"
        label   "Value"
        type    vector2
        size    2
        default { "0" "0" }
        hidewhen    "{ ar_exr_metadata_type# != point2 }"
        range   { -1 1 }
        help "Metadata Point2 value."
        export  none
    }
    parm {
        name    "ar_exr_metadata_matrix_value#"
        label   "Value"
        type    float
        size    16
        default { "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0" }
        hidewhen    "{ ar_exr_metadata_type# != matrix }"
        range   { 0 10 }
        help "Metadata matrix value."
        export  none
    }
    parm {
        name    "ar_exr_metadata_string_value#"
        label   "Value"
        type    string
        default { "" }
        hidewhen    "{ ar_exr_metadata_type# != string }"
        range   { 0 1 }
        help "Metadata string value."
        export  none
    }
    }
    parm {
        SOHO_STRING(ar_tiff_format, "Pixel Format", "Output", 0)
        menu {
            "int8"    "Integer 8 bit         "
            "int16"   "Integer 16 bit"
            "int32"   "Integer 32 bit"
            "float32" "Float 32 bit"
        }
        joinnext
        hidewhen "{ ar_picture_format != tiff }"
        help "TIFF bit depth."
    }
    parm {
        SOHO_STRING(ar_tiff_compression, " Compression", "Output", "lzw")
        menu {
            "none"      "None"
            "lzw"       "LZW"
            "ccittrle"  "CCITT RLE"
            "zip"       "Zip"
            "packbits"  "PackBits"
        }
        hidewhen "{ ar_picture_format != tiff }"
        help "Specifies the compression mode of the TIFF file."
    }
    parm {
        SOHO_TOGGLE(ar_picture_output_padded, "Pad Crop Region", "Output", 0)
        hidewhen "{ ar_picture_format == exr } { ar_picture_format == deepexr }"
        help "Defines a padding around the crop region."
    }
    parm {
        SOHO_TOGGLE(ar_picture_dither, "Dithering", "Output", 1)
        hidewhen "{ ar_picture_format == exr } { ar_picture_format == deepexr }"
        help "Applies a small amount of noise to the final pixel values. This helps minimize banding artifacts apparent on 8-bit output image file formats such as TIFF8."
    }
    parm {
        SOHO_TOGGLE(ar_tiff_unpremult_alpha, "Unpremultiply Alpha", "Output", 0)
        hidewhen "{ ar_picture_format != tiff }"
        help    "Specifies whether the main RGB channel is premultiplied with the alpha channel (the default) or not. It only works with 8-bit output images."
    }
    parm {
        SOHO_TOGGLE(ar_tiff_skip_alpha, "Skip Alpha", "Output", 0)
        hidewhen "{ ar_picture_format != tiff }"
        help    "Skip the alpha channel of RGBA outputs."
    }
    parm {
        SOHO_STRING(ar_png_format, "Pixel Format", "Output", 'int8')
        menu {
            "int8" "Integer 8 bit         "
            "int16" "Integer 16 bit"
        }
        hidewhen "{ ar_picture_format != png }"
        help "PNG bit depth."
    }
    parm {
        SOHO_INT(ar_jpeg_quality, "JPEG Quality", "Output", 100)
        range { 1! 100! }
        hidewhen "{ ar_picture_format != jpeg }"
        help "JPEG compression quality."
    }
    parm {
        SOHO_FLOAT(ar_output_driver_gamma, "Output Gamma", "Output", 1)
        range { 0! 3 }
        hidewhen "{ ar_picture_format == exr } { ar_picture_format == deepexr }"
        disablewhen "{ ar_tiff_format == float32 }"
        help "This is the output gamma applied to the images written to disk by any of Arnold's output drivers. The value is ignored if the output is a floating point image (such as EXR or float32 TIFF)."
    }

    collection {
    name    sep_output1
    label   "sep_output1"
    parmtag { spare_category "Output" }
        parm {
            name    "my_sep_output1"
            label   "Separator"
            type    separator
        }
    }
    
    parm {
        SOHO_STRING(ar_pixel_filter_type, "Pixel Filter", "Output", "gaussian_filter")
        AR_PIXEL_FILTER_MENU
        disablewhen "{ ar_picture_format == deepexr ar_deepexr_enable_filtering == 0 }"
        help    "The filter type used for averaging individual subpixel samples into a final pixel color. The default gaussian-2.0 is an excellent filter, you will rarely need anything other than gaussian."
    }
    parm {
        SOHO_FLOAT(ar_pixel_filter_width, "Filter Width", "Output", 2.0)
        range { 0! 6 }
        disablewhen "{ ar_picture_format == deepexr ar_deepexr_enable_filtering == 0 }"
        hidewhen "{ ar_pixel_filter_type == blackman_harris_filter } \
                  { ar_pixel_filter_type == sinc_filter } \
                  { ar_pixel_filter_type == farthest_filter } \
                  { ar_pixel_filter_type == closest_filter } \
                  { ar_pixel_filter_type == box_filter } \
                  { ar_pixel_filter_type == catrom_filter } \
                  { ar_pixel_filter_type == video_filter } \
                  { ar_pixel_filter_type == heatmap_filter } \
                  { ar_pixel_filter_type == catrom2d_filter } \
                  { ar_pixel_filter_type == cubic_filter } \
                  { ar_pixel_filter_type == mitnet_filter }"
        help "The width of the subpixel sample averaging filter, in pixels. For circularly symmetric filters, this is the diameter of the filter's support."
    }
    parm {
        SOHO_FLOAT(ar_pixel_filter_width_blackman_harris, "Filter Width", "Output", 3.0)
        range { 0! 6 }
        disablewhen "{ ar_picture_format == deepexr ar_deepexr_enable_filtering == 0 }"
        hidewhen "{ ar_pixel_filter_type != blackman_harris_filter }"
        help "The width of the subpixel sample averaging filter, in pixels. For circularly symmetric filters, this is the diameter of the filter's support."
    }
    parm {
        SOHO_FLOAT(ar_pixel_filter_width_sinc, "Filter Width", "Output", 6.0)
        range { 0! 10 }
        disablewhen "{ ar_picture_format == deepexr ar_deepexr_enable_filtering == 0 }"
        hidewhen "{ ar_pixel_filter_type != sinc_filter }"
        help "The width of the subpixel sample averaging filter, in pixels. For circularly symmetric filters, this is the diameter of the filter's support."
    }
    parm {
        SOHO_STRING(ar_pixel_filter_farthest_domain, "Farthest Domain", "Output", "first_hit")
        menu {
            "first_hit" "First Hit                   "
            "all_hits"  "All Hits"
        }
        disablewhen "{ ar_picture_format == deepexr ar_deepexr_enable_filtering == 0 }"
        hidewhen "{ ar_pixel_filter_type != farthest_filter }"
        help    "TODO"
    }
    parm {
        SOHO_TOGGLE(ar_pixel_filter_variance_scalar_mode, "Variance Scalar Mode", "Output", 0)
        disablewhen "{ ar_picture_format == deepexr ar_deepexr_enable_filtering == 0 }"
        hidewhen "{ ar_pixel_filter_type != variance_filter }"
        help "TODO"
    }
    parm {
        SOHO_FLOAT(ar_pixel_filter_heatmap_minimum, "Heatmap Minimum", "Output", 0.0)
        range { 0 1 }
        disablewhen "{ ar_picture_format == deepexr ar_deepexr_enable_filtering == 0 }"
        hidewhen "{ ar_pixel_filter_type != heatmap_filter }"
        help "TODO"
    }
    parm {
        SOHO_FLOAT(ar_pixel_filter_heatmap_maximum, "Heatmap Maximum", "Output", 1.0)
        range { 0 1 }
        disablewhen "{ ar_picture_format == deepexr ar_deepexr_enable_filtering == 0 }"
        hidewhen "{ ar_pixel_filter_type != heatmap_filter }"
        help "TODO"
    }

    collection {
    name    sep_output2
    label   "sep_output2"
    parmtag { spare_category "Output" }
        parm {
            name    "my_sep_output2"
            label   "Separator"
            type    separator
        }
    }
    
    parm {
        SOHO_TOGGLE(ar_enable_aov_composition, "Enable AOV Composition", "Output", 1)
        invisible
        help "Globally control whether any capable AOVs will automatically compose through semi-opaque surfaces rendered using auto-transparency. AOVs which are composable (i.e., which have opacity-blending capability) are provided in the standard, lambert, and hair shaders."
    }
    
    parm {
        SOHO_TOGGLE(ar_multicam, "Enable Multicam", "Output", 1)
        invisible
        help "Helper flag for HtoA to determine if muticam is supported in the render context. IPR contexts disable multicam."
    }

    // AOVs
    multiparm {
        name    ar_aovs
        label   "AOVs"
        parmtag { spare_category        "Output" }
        parm {
            SOHO_TOGGLE("ar_enable_aov#", "Enable AOV #", "Output", 1)
            joinnext
            nolabel
        }
        parm {
            SOHO_STRING("ar_aov_label#", "AOV #", "Output", "")
            AR_LABEL_MENU
            disablewhen "{ \"ar_enable_aov#\" == 0 }"
            help        "The AOV name"
            callback    "opparm . vm_vextype_plane$script_multiparm_index ( `ifs(index(\",Pz,Af,Render_Time,Op_Id,Prim_Id,level,specularlevel,diffuselevel,direct_samples,indirect_samples,\", \",$script_value,\")>=0, \"float\", \"vector\")` )"
        }
        parm {
            SOHO_TOGGLE("ar_aov_camera_enable#", "Enable AOV Camera", "Output", 0)
            disablewhen "{ \"ar_enable_aov#\" == 0 } { \"ar_aov_label#\" == \"\" }"
            nolabel
            help "Enable using a separable camera for this AOV."
            joinnext
        }
        parm {
            SOHO_PARM("ar_aov_camera#", "Camera", "Output", oppath, 1, "")
            parmtag { "opfilter" "!!OBJ/CAMERA!!" }
            disablewhen "{ \"ar_enable_aov#\" == 0 } { \"ar_aov_label#\" == \"\" } { \"ar_aov_camera_enable#\" == 0 }"
            help "The camera to use for this AOV. When the camera is different from the main camera, you need to specify a separate file to render the AOV to. Also, the AOV will be ignored in interactive rendering contexts."
        }
        parm {
            SOHO_TOGGLE("ar_aov_separate#", "Output to Separate File", "Output", 0)
            disablewhen "{ \"ar_enable_aov#\" == 0 } { \"ar_aov_label#\" == \"\" }"
            nolabel
            help "Save this deep raster plane to a different disk file than the main image."
            joinnext
        }
        parm {
            SOHO_FILE("ar_aov_separate_file#", "Separate File", "Output", "")
            parmtag     { filechooser_mode      "write" }
            disablewhen "{ \"ar_enable_aov#\" == 0 } { \"ar_aov_label#\" == \"\" } { \"ar_aov_separate#\" == 0 } { \"ar_aov_camera#\" == camera }"
            menureplace {
                [ "echo `pythonexprs(\"__import__('toolutils').parseDialogScriptMenu('FBrender')\")`" ]
                [ ]
            }
            help "Save this deep raster plane to a different disk file than the main image.\nThis does *not* work when rendering to mplay."
        }
        parm {
            SOHO_STRING("ar_aov_picture_format#", "Image Format", "Output", "beauty")
                AR_AOV_IMAGE_FORMAT_MENU
                disablewhen "{ \"ar_enable_aov#\" == 0 } { \"ar_aov_label#\" == \"\" } { \"ar_aov_separate#\" == 0 }"
                joinnext
                help "AOV image file format."
        }
        parm {
            SOHO_STRING("ar_aov_type#", "  Type", "Output", "RGB")
            AR_TYPE_MENU
            disablewhen "{ \"ar_enable_aov#\" == 0 } { \"ar_aov_label#\" == \"\" }"
            help "The type associated with the AOV"
        }
        parm {
            SOHO_STRING("ar_aov_pixel_filter#", "Pixel Filter", "Output", "beauty")
            AR_AOV_PIXEL_FILTER_MENU
            disablewhen "{ \"ar_enable_aov#\" == 0 } \
                         { \"ar_aov_label#\" == \"\" } \
                         { \"ar_aov_separate#\" == 0 ar_picture_format == deepexr } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == deepexr \"ar_aov_deep_enable_filtering#\" == 0 } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == beauty ar_picture_format == deepexr \"ar_aov_deep_enable_filtering#\" == 0 }"
            joinnext
            help "The filter type used for averaging individual subpixel samples into a final pixel color. The default gaussian-2.0 is an excellent filter, you will rarely need anything other than gaussian."
        }
        parm {
            SOHO_TOGGLE("ar_aov_deep_enable_filtering#", "Filter Deep AOV", "Output", 1)
            disablewhen "{ \"ar_enable_aov#\" == 0 } \
                         { \"ar_aov_label#\" == \"\" } \
                         { \"ar_aov_separate#\" == 0 ar_picture_format != deepexr } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" != deepexr \"ar_aov_picture_format#\" != beauty } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == beauty ar_picture_format != deepexr }"
            help "If set to false disable any filtering operation on this layer's raw data -- useful for normals or ID layers."
        }
        parm {
            SOHO_FLOAT("ar_aov_pixel_filter_width#", "Width", "Output", 2.0)
            range { 0! 6 }
            disablewhen "{ \"ar_enable_aov#\" == 0 } \
                         { \"ar_aov_label#\" == \"\" } \
                         { \"ar_aov_separate#\" == 0 ar_picture_format == deepexr } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == deepexr \"ar_aov_deep_enable_filtering#\" == 0 } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == beauty ar_picture_format == deepexr \"ar_aov_deep_enable_filtering#\" == 0 }"
            hidewhen "{ \"ar_enable_aov#\" == 0 } \
                      { \"ar_aov_pixel_filter#\" == beauty } \
                      { \"ar_aov_pixel_filter#\" == blackman_harris_filter } \
                      { \"ar_aov_pixel_filter#\" == sinc_filter } \
                      { \"ar_aov_pixel_filter#\" == farthest_filter } \
                      { \"ar_aov_pixel_filter#\" == closest_filter } \
                      { \"ar_aov_pixel_filter#\" == box_filter } \
                      { \"ar_aov_pixel_filter#\" == catrom_filter } \
                      { \"ar_aov_pixel_filter#\" == video_filter } \
                      { \"ar_aov_pixel_filter#\" == heatmap_filter } \
                      { \"ar_aov_pixel_filter#\" == catrom2d_filter } \
                      { \"ar_aov_pixel_filter#\" == cubic_filter } \
                      { \"ar_aov_pixel_filter#\" == mitnet_filter }"
            help "The width of the subpixel sample averaging filter, in pixels. For circularly symmetric filters, this is the diameter of the filter's support."
        }
        parm {
            SOHO_FLOAT("ar_aov_pixel_filter_width_blackman_harris#", "Width", "Output", 3.0)
            range { 0! 6 }
            disablewhen "{ \"ar_enable_aov#\" == 0 } \
                         { \"ar_aov_label#\" == \"\" } \
                         { \"ar_aov_separate#\" == 0 ar_picture_format == deepexr } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == deepexr \"ar_aov_deep_enable_filtering#\" == 0 } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == beauty ar_picture_format == deepexr \"ar_aov_deep_enable_filtering#\" == 0 }"
            hidewhen "{ ar_aov_pixel_filter# != blackman_harris_filter }"
            help "The width of the subpixel sample averaging filter, in pixels. For circularly symmetric filters, this is the diameter of the filter's support."
        }
        parm {
            SOHO_FLOAT("ar_aov_pixel_filter_width_sinc#", "Width", "Output", 6.0)
            range { 0! 10 }
            disablewhen "{ \"ar_enable_aov#\" == 0 } \
                         { \"ar_aov_label#\" == \"\" } \
                         { \"ar_aov_separate#\" == 0 ar_picture_format == deepexr } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == deepexr \"ar_aov_deep_enable_filtering#\" == 0 } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == beauty ar_picture_format == deepexr \"ar_aov_deep_enable_filtering#\" == 0 }"
            hidewhen "{ ar_aov_pixel_filter# != sinc_filter }"
            help "The width of the subpixel sample averaging filter, in pixels. For circularly symmetric filters, this is the diameter of the filter's support."
        }
        parm {
            SOHO_STRING("ar_aov_pixel_filter_farthest_domain#", "Farthest Domain", "Output", "first_hit")
            menu {
                "first_hit" "First Hit                   "
                "all_hits"  "All Hits"
            }
            disablewhen "{ \"ar_enable_aov#\" == 0 } \
                         { \"ar_aov_label#\" == \"\" } \
                         { \"ar_aov_separate#\" == 0 ar_picture_format == deepexr } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == deepexr \"ar_aov_deep_enable_filtering#\" == 0 } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == beauty ar_picture_format == deepexr \"ar_aov_deep_enable_filtering#\" == 0 }"
            hidewhen "{ ar_aov_pixel_filter# != farthest_filter }"
            help    "TODO"
        }
        parm {
            SOHO_TOGGLE("ar_aov_pixel_filter_variance_scalar_mode#", "Variance Scalar Mode", "Output", 0)
            disablewhen "{ \"ar_enable_aov#\" == 0 } \
                         { \"ar_aov_label#\" == \"\" } \
                         { \"ar_aov_separate#\" == 0 ar_picture_format == deepexr } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == deepexr \"ar_aov_deep_enable_filtering#\" == 0 } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == beauty ar_picture_format == deepexr \"ar_aov_deep_enable_filtering#\" == 0 }"
            hidewhen "{ ar_aov_pixel_filter# != variance_filter }"
            help "TODO"
        }
        parm {
            SOHO_FLOAT("ar_aov_pixel_filter_heatmap_minimum#", "Heatmap Minimum", "Output", 0.0)
            range { 0 1 }
            disablewhen "{ \"ar_enable_aov#\" == 0 } \
                         { \"ar_aov_label#\" == \"\" } \
                         { \"ar_aov_separate#\" == 0 ar_picture_format == deepexr } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == deepexr \"ar_aov_deep_enable_filtering#\" == 0 } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == beauty ar_picture_format == deepexr \"ar_aov_deep_enable_filtering#\" == 0 }"
            hidewhen "{ ar_aov_pixel_filter# != heatmap_filter }"
            help "TODO"
        }
        parm {
            SOHO_FLOAT("ar_aov_pixel_filter_heatmap_maximum#", "Heatmap Maximum", "Output", 1.0)
            range { 0 1 }
            disablewhen "{ \"ar_enable_aov#\" == 0 } \
                         { \"ar_aov_label#\" == \"\" } \
                         { \"ar_aov_separate#\" == 0 ar_picture_format == deepexr } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == deepexr \"ar_aov_deep_enable_filtering#\" == 0 } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == beauty ar_picture_format == deepexr \"ar_aov_deep_enable_filtering#\" == 0 }"
            hidewhen "{ ar_aov_pixel_filter# != heatmap_filter }"
            help "TODO"
        }
        parm {
            SOHO_FLOAT("ar_aov_deep_merge_tolerance#", "Deep AOV Tolerance", "Output", 0.01)
            range { 0! 10 }
            logarithmic
            disablewhen "{ \"ar_enable_aov#\" == 0 } \
                         { \"ar_aov_label#\" == \"\" } \
                         { ar_deepexr_subpixel_merge == 0 } \
                         { \"ar_aov_separate#\" == 0 ar_picture_format != deepexr } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" != deepexr \"ar_aov_picture_format#\" != beauty } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == beauty ar_picture_format != deepexr }"
            help "Tolerance over which the AOV samples will not be merged together."
        }
        parm {
            SOHO_TOGGLE("ar_aov_deep_half_precision#", "Half Precision for Deep AOV", "Output", 0)
            disablewhen "{ \"ar_enable_aov#\" == 0 } \
                         { \"ar_aov_label#\" == \"\" } \
                         { \"ar_aov_separate#\" == 0 ar_picture_format != deepexr } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" != deepexr \"ar_aov_picture_format#\" != beauty } \
                         { \"ar_aov_separate#\" == 1 \"ar_aov_picture_format#\" == beauty ar_picture_format != deepexr }"
            help "Use 16-bit floats for this AOV filtering."
        }
    }

    // Image parameters
    collection {
        name    override_resolution
        label   "Override Res"
        parmtag { spare_category    "Output" }
        parm    {
            name    override_camerares
            label   "Override Camera Resolution"
            parmtag { spare_category    "Output" }
            type    toggle
            default { 0 }
        }
        parm {
            name    res_fraction
            label   "Resolution Scale"
            parmtag { spare_category    "Output" }
            type    string
            default { "specific" }
            menu    {
            "0.1"       "1/10 (One Tenth Resolution)"
            "0.2"       "1/5 (One Fifth Resolution)"
            "0.25"      "1/4 (Quarter Resolution)"
            "0.3333333" "1/3 (One Third Resolution)"
            "0.5"       "1/2 (Half Resolution)"
            "0.6666666" "2/3 (Two Thirds Resolution)"
            "0.75"      "3/4 (Three Quarter Resolution)"
            "specific"  "User Specified Resolution"
            }
            hidewhen "{ override_camerares == 0 }"
        }
        parm {
            name    res_override
            label   Resolution
            parmtag { spare_category    "Output" }
    
            type    intvector2
            default { 640 480 }
            hidewhen "{ override_camerares == 0 } { res_fraction != specific }"
            joinnext
        }
        parm {
            name    res_overrideMenu
            label   "Choose Resolution"
            parmtag { spare_category    "Output" }
            type    button
            nolabel
            callback    "opparm . res_override ( `arg(\"$script_value\", 0)` `arg(\"$script_value\", 1)` aspect_override ( `arg(\"$script_value\", 2)` )"
            hidewhen "{ override_camerares == 0 } { res_fraction != specific }"
            menumini    {
            RESOLUTION_MENU
            }
        }
        parm {
            name    aspect_override
            label   "Pixel Aspect Ratio"
            parmtag { spare_category "Output" }
            type    float
            size    1
            default { 1 }
            range   { 0.05 2 }
            hidewhen "{ override_camerares == 0 }"
        }
        parm {
            name    "my_sep"
            label   "Separator"
            type    separator
            hidewhen "{ override_camerares == 0 }"
        }
    }
    
    // Overscan
    collection {
        name    overscan_resolution
        label   "Overscan Res"
        parmtag { spare_category    "Output" }
        parm {
            name    "ar_overscan_enable"
            label   "Overscan"
            type    toggle
            default { 0 }
            help    "Enable rendered image overscan."
        }
        parm {
            name    "ar_overscan"
            label   "Overscan Margins"
            type    intvector4
            size    4
            default { "0" "ch(\"ar_overscanx\")" "ch(\"ar_overscanx\")" "ch(\"ar_overscanx\")" }
            help    "Extend the render region by those amounts in pixels. EXR output will fully respect  the overscan region with differing data and display windows, but the other  image formats will simply enlarge the final image resolution to incorporate overscan since they cannot accommodate data outside the display area of the image."
            hidewhen "{ ar_overscan_enable == 0 }"
            range   { 0! 100 }
        }
        parm {
            name    "ar_overscan_label"
            label   " "
            type    label
            size    4
            default { "Top" "Bottom" "Left" "Right" }
            hidewhen    "{ ar_overscan_enable == 0 }"
        }
        parm {
            name    "ar_overscan_separator"
            label   "Separator"
            type    separator
            hidewhen "{ ar_overscan_enable == 0 }"
        }
    }

    // this flag is set whenever the properties have been overidden 
    parm {
        name    "ar_overridden"
        label   "Overridden Parameters"
        type    toggle
        default { 0 }
        help    "Parameters have been overridden by one of the configuration files in $HH/soho/overrides."
        range   { 0 1 }
        invisible
        export  none
        parmtag { "spare_category" "Output" }
    }
    
    ///////////////////////////////////////////////////////////////////////////
    // Sampling
    //
    parm {
        SOHO_INT(ar_AA_samples, "Camera (AA)", "Sampling", 3)
        range { 1 10 }
        help "Controls the amount of rays per pixel that will be traced from the camera. The higher the number of samples, the better the anti-aliasing quality, and the longer the render times. The exact number of rays per pixel is the square of this value. For example, an AA Samples value of 3 means 3x3 = 9 pixel samples."
    }
    parm {
        SOHO_INT(ar_GI_diffuse_samples, "Diffuse", "Sampling", 2)
        range { 0! 10 }
        help "The number of hemispherical rays fired for indirect diffuse GI shader evaluations. Increase this number to reduce the diffuse GI noise. The exact number of hemispherical rays is the square of this value."
    }
    parm {
        SOHO_INT(ar_GI_glossy_samples, "Glossy", "Sampling", 2)
        range { 0! 10 }
        help "The number of BRDF rays fired for indirect glossy specular shader evaluations. Increase this number to reduce the noise in soft/blurry reflections. The exact number of rays is the square of this value."
    }
    parm {
        SOHO_INT(ar_GI_refraction_samples, "Refraction", "Sampling", 2)
        range { 0! 10 }
        help "The number of samples used to simulate the microfacet-based glossy refraction evaluations."
    }
    parm {
        SOHO_INT(ar_GI_single_scatter_samples, "Single Scatter", "Sampling", 5)
        range { 0! 16 }
        help "Control the quality of the SSS computation done by AiSSSTraceSingleScatter(), a single scattered ray traced SSS computation based on the BSSRDF formulation by Henrik Wann Jensen et al."
    }
    parm {
        SOHO_INT(ar_sss_bssrdf_samples, "SSS", "Sampling", 3)
        range { 0! 10 }
        help "The number of SSS lighting samples (direct and indirect) that will be taken to estimate lighting within a radius of the point being shaded. Higher values produce a cleaner solution, but will take longer to render."
    }
    parm {
        SOHO_INT(ar_volume_indirect_samples, "Volume Indirect", "Sampling", 2)
        range { 0! 10 }
        help "The number of indirect diffuse samples for volumes. Higher values reduce the noise, but will take longer to render."
    }
    parm {
        SOHO_TOGGLE(ar_AA_sample_clamp_enable, "Clamp Sample Values", "Output", 0)
        help "When enabled, pixel samples will be clamped to the specified maximum value. This can make it easier to anti-alias certain high-dynamic range effects such as bright motion blurred specular streaks (at the cost of reduced contrast)."
    }
    parm {
        SOHO_TOGGLE(ar_AA_sample_clamp_affects_aovs, "Clamp Sample Values in AOVs", "Output", 0)
        disablewhen "{ ar_AA_sample_clamp_enable != 1 }"
        help "When enabled, pixel samples will be clamped to the specified maximum value. This can make it easier to anti-alias certain high-dynamic range effects such as bright motion blurred specular streaks (at the cost of reduced contrast)."
    }
    parm {
        SOHO_FLOAT(ar_AA_sample_clamp, "Max. Sample Value", "Output", 10)
        disablewhen "{ ar_AA_sample_clamp_enable == 0 ar_AA_sample_clamp_affects_aovs == 0 }"
        range { 0.00001! 100 }
        help "Enabling this control, pixel samples will be clamped to the specified maximum value. This can make it easier to anti-alias certain high-dynamic range effects such as bright motion blurred specular streaks (at the cost of reduced contrast)."
    }
    parm {
        SOHO_INT(ar_AA_seed, "Noise Seed", "Sampling", "$F")
        range { 0 9999 }
        help "The noise pattern seed for AA sampling."
    }
    parm {
        SOHO_TOGGLE(ar_trace_opaque_first, "Trace Opaque First", "Sampling", 0)
        help "Will override the diffuse samples value (ar_GI_diffuse_samples) for the SSS irradiance evaluations"
    }
    parm {
        SOHO_TOGGLE(ar_sss_use_autobump, "Autobump for SSS", "Sampling", 0)
        help "Take autobump into account for SSS calculations. This will result in more details in the SSS, at the cost of a slower render."
    }

    parm {
    name    "spacer_sampling1"
    label   "Label"
    type    label
    default { " " }
    nolabel
    parmtag { spare_category "Sampling" }
    }
    
    collection {
    name    sep_sampling1
    label   "sep_sampling1"
    parmtag { spare_category "Sampling" }
        parm {
            name    "my_sep_sampling1"
            label   "Separator"
            type    separator
        }
    }
    
    ///////////////////////////////////////////////////////////////////////////
    // Motion blur
    //
    parm {
        SOHO_TOGGLE(ar_mb_xform_enable, "Enable Transformation Blur", "Motion Blur", 0)
        nolabel
        joinnext
        help "Enable motion blur."
    }
    parm {
        SOHO_TOGGLE(ar_curved_motionblur, "Curved Transformation Blur", "Motion Blur", 1)
        disablewhen "{ ar_mb_xform_enable == 0 }"
        help "Enable curved motion blur for transforms."
    }
    parm {
        SOHO_TOGGLE(ar_mb_dform_enable, "Enable Deformation Blur", "Motion Blur", 0)
        nolabel
        joinnext
        help "Motion blur will take into account geometry deformation. It should only be enabled when objects in the scene change shape quickly enough, since this option uses more memory and renders slower."
    }
    parm {
        SOHO_INT(ar_mb_xform_keys, "Transform Keys", "Motion Blur", 2)
        range { 1! 20 }
        disablewhen "{ ar_mb_xform_enable == 0 }" 
        help "Number of motion keys for matrix transformation. Transformation motion blur is calculated based on a linear interpolation of an object transform matrix, between successive motion keys. Increasing this value will add extra steps, which can improve the blurred result specially for rotating objects. The default is 2, which results in straight lines of blur between shutter start and shutter end."
    }
    parm {
        SOHO_INT(ar_mb_dform_keys, "Deform Keys", "Motion Blur", 2)
        range { 1! 20 }
        disablewhen "{ ar_mb_dform_enable == 0 }" 
        help "Number of motion keys for object points. Just like with transformation motion keys, increasing this value allows curved motion paths to be rendered more accurately, at the expense of using more memory."
    }
    parm {
        SOHO_STRING(ar_mb_shutter, "Shutter Position", "Motion Blur", "center")
        menu {
            "start"     "Start On Frame"
            "center"    "Center On Frame"
            "end"       "End On Frame"
            "custom"    "Custom Shutter"
        }
        disablewhen "{ ar_mb_xform_enable == 0 ar_mb_dform_enable == 0 }" 
        help "Decide where on the frame time the blur will be evaluated. The default is centered."
    }
    parm {
        name    "ar_mb_shutter_length"
        label   "Shutter Length"
        type    float
        default { "0.5" }
        parmtag { spare_category "Motion Blur" }
        hidewhen    "{ ar_mb_shutter == custom }"
        disablewhen "{ ar_mb_xform_enable == 0 ar_mb_dform_enable == 0 }"
        range   { 0 1 }
        export  none
    }
    parm {
        name    "ar_mb_shutter_range"
        label   "Shutter Start/End"
        type    vector2
        size    2
        default { "-0.25" "0.25" }
        parmtag { spare_category "Motion Blur" }
        hidewhen    "{ ar_mb_shutter != custom }"
        disablewhen "{ ar_mb_xform_enable == 0 ar_mb_dform_enable == 0 }"
        range   { -1 1 }
        export  none
    }
    parm {
        SOHO_FLOAT(ar_reference_time, "Reference Time", "Motion Blur", [ "\
shutter_parm = hou.parm('ar_mb_shutter')\n\
shutter_type = shutter_parm.eval()\n\
\n\
if shutter_type == 'custom':\n\
    shutter = sorted(hou.parmTuple('ar_mb_shutter_range').eval())\n\
    shutter_length = shutter[1] - shutter[0]\n\
    # result is clamped to [0, 1] by the parm range\n\
    return 0 if shutter_length == 0 else -shutter[0] / shutter_length\n\
else:\n\
    return 0.5 * shutter_parm.menuItems().index(shutter_type)\n" python ])
        range { 0! 1! }
        disablewhen "{ ar_mb_xform_enable == 0 ar_mb_dform_enable == 0 } { ar_ignore_motion_blur == 0 }"
        help "When disabling motion blur with ignore_motion_blur, the time specified by reference_time will be used instead of the shutter open time. This time is mapped on [0, 1], with 0 being the shutter open and 1 the shutter close."
    }

    //////////////////////////////////////////////////////////////////////////
    // Depth of field
    //
    parm {
        name    "ar_dof_enable"
        label   "Enable Depth of Field"
        type    toggle
        default { "0" }
        joinnext
        help    "Enables depth of field effects."
        range   { 0 1 }
        export  none
        parmtag { spare_category "Sampling" }
    }
    collection {
    name    sep_sampling2
    label   "sep_sampling2"
    parmtag { spare_category "Sampling" }
        parm {
            name    "my_sep_sampling2"
            label   "Separator"
            type    separator
        }
    }
    parm {
        name    "ar_aperture_size"
        label   "Aperture Size"
        type    float
        default { "0" }
        disablewhen "{ ar_dof_enable == 0 }"
        range   { 0 10 }
        export  none
        parmtag { spare_category "Sampling" }
        parmtag { "units" "m1" }
    }
    parm {
        name    "ar_aperture_polygonal"
        label   "Polygonal Aperture"
        type    toggle
        nolabel
        joinnext
        default { "1" }
        help    "Whether the aperture will behave as a regular polygon of N-sides or as a perfect disk."
        disablewhen "{ ar_dof_enable == 0 }"
        range   { 0 1 }
        export  none
        parmtag { spare_category "Sampling" }
    }
    parm {
        name    "ar_aperture_blades"
        label   "Aperture Blades"
        type    integer
        default { "5" }
        help    "Number of blades (or polygon sides) of the polygonal aperture."
        disablewhen "{ ar_dof_enable == 0 } { ar_aperture_polygonal == 0 }"
        range   { 3! 20 }
        export  none
        parmtag { spare_category "Sampling" }
    }
    parm {
        name    "ar_aperture_blade_curvature"
        label   "Blade Curvature"
        type    float
        default { "0" }
        help    "Curvature of the polygonal aperture sides. A value of 0 means hard straight sides. Increasing this value results in progressively more curved edges, all the way to 1.0 which produces a perfect disk. Negative values produce a \"pinched\" or star-shaped aperture."
        disablewhen "{ ar_dof_enable == 0 } { ar_aperture_polygonal == 0 }"
        range   { -5 1 }
        export  none
        parmtag { spare_category "Sampling" }
    }
    parm {
        name    "ar_aperture_aspect_ratio"
        label   "Aspect Ratio"
        type    float
        logarithmic
        default { "1" }
        help    "This is used to stretch the aperture vertically. A value of 2 produces an elongated defocusing effect reminiscent of an anamorphic lens, while a value less than one will squash it."
        disablewhen "{ ar_dof_enable == 0 }"
        range   { 0.05 20 }
        export  none
        parmtag { spare_category "Sampling" }
    }
    parm {
        name    "ar_aperture_rotation"
        label   "Aperture Rotation"
        type    float
        default { "0" }
        help    "Rotates the aperture by any number of degrees."
        disablewhen "{ ar_dof_enable == 0 }"
        range   { -180 180 }
        export  none
        parmtag { spare_category "Sampling" }
    }
    
    //////////////////////////////////////////////////////////////////////////
    // Tessellation
    //
    parm {
        SOHO_INT(ar_max_subdivisions, "Max. Subdivisions", "Tessellation", 999)
        range { 0! 999! }
        help "This value sets an upper limit on the number of subdivision iterations for all objects. By default this is set to a very high value (999) which in practice has no effect. Setting this to a low value such as 1 or 2 can be useful when debugging scenes that take a long time to subdivide/tessellate."
    }
    parm {
        SOHO_FLOAT(ar_subdiv_pixel_error, "Subdiv. Pixel Error", "Tessellation", 0)
        range { 0! 10 }
        help "The \"pixel error\" refers to the acceptable tessellation error as seen from the camera, in pixels. If there's no displacement, then the pixel error represents the distance (in pixels) from the subdivided mesh to the \"true\" or \"limit\" surface -- sort of a \"flatness\" heuristic. The smaller the error, the closer to the limit surface a mesh will be and the less inter-frame \"popping\" when the subdivision level jumps. If displacement is enabled, then the pixel error represents the final size of the subdivided quads (again, in pixels). A value of 0 disables adaptive subdivision."
    }
    parm {
        SOHO_TOGGLE(ar_subdiv_dicing_camera_enable, "Use Alternate Dicing Camera", "Tessellation", 0)
        nolabel
        joinnext
        help "This is mostly useful for debugging and rarely used in practice. When enabled, the user provides a specific camera that will be used for all dicing calculations during Adaptative Subdivision. By default this is disabled, meaning that the current render camera also serves as dicing camera."
    }
    parm {
        SOHO_PARM(ar_subdiv_dicing_camera, "Dicing Camera", "Tessellation", oppath, 1, "/obj/cam1")
        parmtag { "oprelative" "." }
        parmtag { "opfilter" "!!OBJ/CAMERA!!" }
        disablewhen "{ ar_subdiv_dicing_camera_enable == 0 }"
        help "The camera that will be used for dicing calculations during Adaptative Subdivision."
    }
    
    parm {
        SOHO_TOGGLE(ar_tessellation_enable, "Tessellate Surface Primitives", "Tessellation", 0)
        help "Enable tessellation of Houdini primitives prior to sending to Arnold"
    }
    parm {
        SOHO_STRING(ar_tessellation_style, "Tessellation Style", "Tessellation", "lod")
        menu {
            "lod"   "Level of Detail"
            "div"   "Divisions"
        }
        disablewhen "{ ar_tessellation_enable == 0 }"
        help "Specifies the conversion style for the geometry. The default is\"Level of Detail\". Can be one of the following:\n- Level of Detail: Tessellate geometry using the level of detail settings.\n- Divisions: Tessellate geometry based on the number of divisions settings."
    }
    parm {
        SOHO_FLOAT(ar_tessellation_ulod, "U Level of Detail", "Tessellation", 1.0)
        range { 0! 10 }
        disablewhen "{ ar_tessellation_enable == 0 }"
        hidewhen "{ ar_tessellation_style != lod }"
        help "Specifies the level of detail for U subdivisions of the surface being converted. Applicable only when conversion method is set to Level of Detail. Defaults to 1.0."
    }
    parm {
        SOHO_FLOAT(ar_tessellation_vlod, "V Level of Detail", "Tessellation", 1.0)
        range { 0! 10 }
        disablewhen "{ ar_tessellation_enable == 0 }"
        hidewhen "{ ar_tessellation_style != lod }"
        help "Specifies the level of detail for V subdivisions of the surface being converted. Applicable only when conversion method is set to Level of Detail. Defaults to 1.0."
    }
    parm {
        SOHO_FLOAT(ar_tessellation_trimlod, "Trim Level of Detail", "Tessellation", 1.0)
        range { 0! 10 }
        disablewhen "{ ar_tessellation_enable == 0 }"
        hidewhen "{ ar_tessellation_style != lod }"
        help "Specifies the level of detail for trim curves of the surface being converted. Applicable only when conversion method is set to Level of Detail. Defaults to 1.0."
    }
    parm {
        SOHO_INT(ar_tessellation_udiv, "U Divisions", "Tessellation", 10)
        range { 0! 50 }
        disablewhen "{ ar_tessellation_enable == 0 }"
        hidewhen "{ ar_tessellation_style != div }"
        help "Specifies the number of U subdivisions of the surface being converted. Applicable only when conversion method is set to Level of Detail. Defaults to 1.0."
    }
    parm {
        SOHO_INT(ar_tessellation_vdiv, "V Divisions", "Tessellation", 10)
        range { 0! 50 }
        disablewhen "{ ar_tessellation_enable == 0 }"
        hidewhen "{ ar_tessellation_style != div }"
        help "Specifies the number of V subdivisions of the surface being converted. Applicable only when conversion method is set to Level of Detail. Defaults to 1.0."
    }
    parm {
        SOHO_INT(ar_tessellation_trimdiv, "Trim Divisions", "Tessellation", 10)
        range { 0! 50 }
        disablewhen "{ ar_tessellation_enable == 0 }"
        hidewhen "{ ar_tessellation_style != div }"
        help "Specifies the number of subdivisions for trim curves of the surface being converted. Applicable only when conversion method is set to Level of Detail. Defaults to 1.0."
    }
    parm {
        SOHO_TOGGLE(ar_tessellation_preservegroups, "Preserve Groups", "Tessellation", 1)
        disablewhen "{ ar_tessellation_enable == 0 }"
        help "If true, groups will be preserved during conversion. Otherwise they will not be copied to the new geometry. True by default."
    }
    parm {
        SOHO_TOGGLE(ar_tessellation_polysides_enable, "Enable Convexing", "Tessellation", 1)
        nolabel
        joinnext
        disablewhen "{ ar_tessellation_enable == 0 }"
        help "Enables convexing polygons to a number of sides."
    }
    parm {
        SOHO_INT(ar_tessellation_polysides, "Convex Sides", "Tessellation", 3)
        range { 3! 10 }
        disablewhen "{ ar_tessellation_enable == 0 } { ar_tessellation_polysides_enable == 0 }"
        help "An integer that specifies the number of sides to convex."
    }
    parm {
        SOHO_TOGGLE(ar_tessellation_metastyle_enable, "Enable Metaballs Tessellation Style", "Tessellation", 1)
        nolabel
        joinnext
        disablewhen "{ ar_tessellation_enable == 0 }"
        help "Enable secondary method for converting metaballs."        
    }
    parm {
        SOHO_STRING(ar_tessellation_metastyle, "Metaballs Style", "Tessellation", "lod")
        menu {
            "lod"   "Level of Detail"
            "div"   "Divisions"
            "step"  "Steps"
            "xsect" "Cross Sections"
        }
        joinnext
        disablewhen "{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
        help "Specifies the style to convert metaballs with. This may be different from the main conversion style, and can be one of the following values:\n- Level of Detail: Use the level of detail conversion method.\n- Divisions: Use a fixed number of subidivisions to convert metaballs.\n- Steps: This option will create slice planes at equally spaced steps.\n- Cross Sections: This option will generate cross sectional polygons. The number of cross sections determines how many cross sections will be built along the axis specified. The maximum depth determines the accuracy of the cross sections."
    }
    parm {
        SOHO_TOGGLE(ar_tessellation_metaadjust, "Align Bounding Box                    ", "Tessellation", 1)
        disablewhen "{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
        help "If true, the bounding box will be aligned so that the slicing planes will not change unless the divisions also change. Defaults to true."
    }
    parm {
        SOHO_FLOAT(ar_tessellation_metalod, "Metaballs LOD", "Tessellation", 1.0)
        joinnext
        disablewhen "{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
        hidewhen "{ ar_tessellation_metastyle != lod }"
        help "Specifies a single LOD value to control tessellation density. Valid only when metaball conversion style is Level of Detail. Defaults to 1.0."
    }
    parm {
        SOHO_TOGGLE(ar_tessellation_metacluster, "Enable Clustering", "Tessellation", 0)
        disablewhen "{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
        hidewhen "{ ar_tessellation_metastyle != lod }"
        help "Enables clustering if true. Valid only when metaball conversion style is lod. Defaults to false."
    }
    parm {
        SOHO_PARM(ar_tessellation_metadiv, "Metaballs Divisions", "Tessellation", int, 3, 10 10 10)
        disablewhen "{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
        hidewhen "{ ar_tessellation_metastyle != div }"
        help "Specifies the number of x, y and z divisions for the bounding box of the geometry. Valid only when metaball conversion style is Divisions. This should be a vector of three integers. Defaults to {10, 10, 10}."
    }
    parm {
        SOHO_PARM(ar_tessellation_metastep, "Metaballs Step Size", "Tessellation", float, 3, 0.1 0.1 0.1)
        disablewhen "{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
        hidewhen "{ ar_tessellation_metastyle != step }"
        help "Specifies x,y and z step sizes for subidivisions. Valid only when metaball conversion style is Steps. This should be a vector of three floating-point numbers. Defaults to {0.1, 0.1, 0.1}."
    }
    parm {
        SOHO_INT(ar_tessellation_metasections, "Cross Sections", "Tessellation", 20)
        range { 0! 100 }
        joinnext
        disablewhen "{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
        hidewhen "{ ar_tessellation_metastyle != xsect }"
        help "Number of cross-sections to build when subdividing. Valid only when metaball conversion style is Cross Section. Defaults to 20"
    }
    parm {
        SOHO_INT(ar_tessellation_metaaxis, "   Axis", "Tessellation", 2)
        range { 0! 2! }
        menu {
            0   "X"
            1   "Y"
            2   "Z"
        }
        disablewhen "{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
        hidewhen "{ ar_tessellation_metastyle != xsect }"
        help "Axis along which cross-section planes will be built. Valid only when metaball conversion style is xsect. This value is an integer between 0 and 2 inclusive. Defaults to 2, that is, the Z axis."
    }
    parm {
        SOHO_INT(ar_tessellation_metamaxdepth, "Maximum Depth", "Tessellation", 5)
        range { 0! 20 }
        disablewhen "{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
        hidewhen "{ ar_tessellation_metastyle != xsect }"
        help "Specifies the maximum depth when building cross-sections. This determines the accuracy of the conversion. Defaults to 5."
    }
    parm {
        SOHO_TOGGLE(ar_tessellation_metaaccnormals, "Accurate Normals", "Tessellation", 1)
        disablewhen "{ ar_tessellation_enable == 0 } { ar_tessellation_metastyle_enable == 0 }"
        help "If true, accurate normals will be computed. This is also the default."
    }
    
    //////////////////////////////////////////////////////////////////////////
    // Ray Depth
    //
    parm {
        SOHO_INT(ar_GI_total_depth, "Total", "Ray Depth", 10)
        range { 0! 16 }
        help "Specifies the total maximum recursion depth of any ray in the scene."
    }
    parm {
        SOHO_INT(ar_GI_diffuse_depth, "Diffuse", "Ray Depth", 1)
        range { 0! 16 }
        help "The maximum number of times a diffuse ray can bounce."
    }
    parm {
        SOHO_INT(ar_GI_reflection_depth, "Reflection", "Ray Depth", 2)
        range { 0! 16 }
        help "The maximum number of times a ray can be specularly reflected."
    }
    parm {
        SOHO_INT(ar_GI_refraction_depth, "Refraction", "Ray Depth", 2)
        range { 0! 16 }
        help "The maximum number of times a ray can be refracted."
    }
    parm {
        SOHO_INT(ar_GI_glossy_depth, "Glossy", "Ray Depth", 1)
        range { 0! 16 }
        help "The maximum number of times a ray can be glossily reflected."
    }
    parm {
        SOHO_INT(ar_GI_volume_depth, "Volume", "Ray Depth", 0)
        range { 0! 16 }
        help "The maximum number of times a ray can bounce for multiple scattering in a volume."
    }
    parm {
        SOHO_INT(ar_auto_transparency_depth, "Transparency", "Ray Depth", 10)
        range { 0! 16 }
        help "The number of allowed transparency hits. With 0 objects will be treated as opaque."
    }
    parm {
        SOHO_STRING(ar_auto_transparency_mode, "Auto-Transp. Mode", "Ray Depth", "always")
        menu {
            "always"        "Always"
            "shadow-only"   "Shadow-Only"
            "never"         "Never"
        }
        joinnext
        help "With the default, \"Always\", Arnold will automatically compute the transparency hits and compositing over primary, secondary and shadow rays. \"Shadow-Only\" will track the transparency hits over the shadow rays only. \"Never\" will entirely disable the computation of transparency."
    }
    parm {
        SOHO_FLOAT(ar_auto_transparency_threshold, "Transp. Threshold", "Ray Depth", 0.99)
        range { 0! 1! }
        disablewhen "{ ar_auto_transparency_mode == never }"
        help "Defines at which point the accumulated opacity can be considered as opaque. This optimization parameter is designed to save computations when an object tagged as transparent have large areas that are nearly opaque."
    }
    parm {
        SOHO_TOGGLE(ar_GI_direct_lighting, "Enable Direct Lighting", "Ray Depth", 1)
        help "When disabled, direct lighting will be invisible for camera rays. This is useful to render indirect-only diffuse pases."
    }
    parm {
        SOHO_FLOAT(ar_low_light_threshold, "Low Light Threshold", "Ray Depth", 0.001)
        range { 0! 0.1 }
        help "Specify an illumination value below which Arnold will skip firing shadow rays to each light source, reducing rendering time."
    }
    
    //////////////////////////////////////////////////////////////////////////
    // Textures
    //
    parm {
        SOHO_FLOAT(ar_texture_glossy_blur, "Glossy Blur", "Textures", 0)
        range { 0! 1 }
        logarithmic
        help "Blurring of texture for lookups by glossy rays. When using the Cook-Torrance BRDF, textures are automatically blurred and this parameter is ignored."
    }
    parm {
        SOHO_FLOAT(ar_texture_diffuse_blur, "Diffuse Blur", "Textures", 0.03125)
        range { 0! 1 }
        logarithmic
        help "Blurring of texture for lookups by diffuse rays."
    }
    parm {
        SOHO_FLOAT(ar_texture_sss_blur, "SSS Blur", "Textures", 0)
        range { 0! 1 }
        logarithmic
        help "Blurring of texture for lookups by SSS rays."
    }
    parm {
        SOHO_FLOAT(ar_texture_max_sharpen, "Sharpness", "Textures", 1.5)
        invisible
        range { 1 10 }
        help "Sharpens textures at the expense of increased file I/O. The theoretical optimum setting for sharpest results is to set this to AA_samples, but under most practical situations where texture I/O must be controlled, setting this to around 1.5 already gives sharp results at a moderate cost."
    }
    parm {
        SOHO_TOGGLE(ar_texture_automip, "Auto-mipmap", "Textures", 1)
        help "If a texture map file is not natively mipmapped (e.g. a JPEG file), enabling this option will trigger the automatic generation of a mipmap that will be stored in memory for the duration of the render. This mipmap generation increases render time, specially for scenes with many high resolution textures. This is in contrast to file formats that natively support mipmapping, such as TIFF and EXR, where the mipmap is generated only once (with a preprocessing tool like maketx). Use with care."
        disablewhen "{ ar_texture_accept_unmipped == 0 }"
    }
    parm {
        SOHO_TOGGLE(ar_texture_accept_untiled, "Accept Untiled", "Textures", 1)
        help "High-resolution untiled texture maps are very inefficient to render, because they must be loaded entirely into memory as soon as the renderer needs to access a single texel. For that reason, you may want to use this flag to enforce that all your texture maps are already tiled in advance (perhaps by using a preprocessing tool like maketx). When this flag is enabled, any attempt at loading an untiled file will produce an error and abort the renderer. By default this flag is enabled, because most of the popular image formats such as JPEG don't support tiling."
        nolabel
        joinnext
    }
    parm {
        SOHO_TOGGLE(ar_texture_accept_unmipped, "Accept Unmipped", "Textures", 1)
        help "Unmipped texture maps are inefficient to render, because filtering to reduce aliasing has to be done on the fly. For that reason, you may want to use this flag to enforce that all your texture maps are already mipmapped in advance (perhaps by using a preprocessing tool like maketx). When this flag is enabled, any attempt at loading an unmipped file will produce an error and abort the renderer. By default this flag is enabled, because most of the popular image formats such as JPEG don't support tiling."
    }
    parm {
        SOHO_INT(ar_texture_autotile, "Auto-tile", "Textures", 64)
        range { 2! 512 }
        disablewhen "{ ar_texture_accept_untiled == 0 }"
        help "This is the size of the tiles when using auto-tiling. Bigger values mean less frequent texture loads, but use more memory. Use existing Tiled files: If .tx file with the same name of the texture is found, the renderer will use it."
    }
    parm {
        SOHO_TOGGLE(ar_texture_use_existing_tx, "Use Existing .tx Textures", "Textures", 0)
        help "If an untiled texture is requested (e.g. concrete.jpg) but a .tx file with the same filename is found (e.g. concrete.tx), the renderer will load the .tx file instead."
    }
    parm {
        SOHO_FLOAT(ar_texture_max_memory_MB, "Cache Size (MB)", "Textures", 1024)
        range { 0! 4096 }
        disablewhen "{ ar_texture_caching_enable == 0 }"
        help "Texture cache size in MB."
    }
    parm {
        SOHO_INT(ar_texture_max_open_files, "Max. Open Textures", "Textures", 0)
        range { 0! 4096 }
        disablewhen "{ ar_texture_max_memory_MB == 0 }"
        help "The maximum number of files that the texture system keeps open at any given time to avoid excessive closing and re-opening of files when caching individual texture tiles. A value of 0 means the number is automatically computed by Arnold. Increasing this number may result in slightly better texture caching performance. On the other hand, if this value is higher than the maximum number of concurrently open files supported by the operating system (e.g. Linux vs Windows), some texture lookups may fail and return red."
    }
    parm {
        SOHO_INT(ar_texture_failure_retries, "Texture Failure Retries", "Textures", 0)
        range { 0! 1024 }
        help "Number of times to retry reading a texture after failure."
    }
    parm {
        SOHO_TOGGLE(ar_texture_conservative_lookups, "Conservative Texture Lookups", "Textures", true)
        help "???"
    }
    parm {
        SOHO_TOGGLE(ar_enable_fast_opacity, "Fast Opacity", "Textures", 1)
        help "Get faster textured mapped opacity mask renders, such as for tree leaves. Tests with production scenes have shown up to 25x speedups. This flag also toggles a fix for more accurate renders, where previously the object would be rendered more transparent when further away from the camera. When using this option, noise/flicker can occur on far away geometry, similar to when rendering far away high res geometry. If this happens, it is best to use a high amount of AA samples (and correspondingly lower amount of diffuse/glossy/light samples) to reduce flickering in animation. The fast opacity flag is enabled for anything that is connected to any RGB parameter called "opacity", so custom shaders that have an RGB opacity parameter will benefit from this. We expect that users will want to enable this mode all the time for new scenes and if no one complains, in a future release we will likely remove this flag and leave the optimizations and fixes in the "fast_opacity" mode always enabled."
        invisible
    }
    
    ///////////////////////////////////////////////////////////////////////////
    // System
    //
    parm {
        SOHO_TOGGLE(ar_force_threads, "Force Threads", "System", 0)
        nolabel
        invisible
        joinnext
        help "Allow manual setting the number of render threads instead of using an optimal number based on the number of hardware processing cores."
    }
    parm {
        SOHO_INT(ar_threads, "Render Threads", "System", 4)
        invisible
        disablewhen "{ ar_force_threads == 0 }"
        range { 1! 64 }
        help "If ar_force_threads is enabled, this will let you manually set the number of rendering threads."
    }
    parm {
        SOHO_STRING(ar_thread_priority, "Thread Priority", "System", "lowest")
        help "Specifies the thread priority for rendering (Windows only)."
        menu {
            "lowest"    "Lowest"
            "low"       "Low"
            "medium"    "Medium"
            "high"      "High"
        }
    }
    parm {
        SOHO_STRING(ar_bucket_scanning, "Bucket Scanning", "System", "spiral")
        help "Specifies the spatial order in which the image buckets (i.e. threads) will be processed. By default, buckets start in the center of the image and proceed outwards in a spiral pattern."
        menu {
            "top"       "Top"
            "bottom"    "Bottom"
            "left"      "Left"
            "right"     "Right"
            "random"    "Random"
            "woven"     "Woven"
            "spiral"    "Spiral"
            "hilbert"   "Hilbert"
        }
    }
    parm {
        SOHO_INT(ar_bucket_size, "Bucket Size", "System", 64)
        range { 16! 256 }
        help "The size of the image buckets. The default size is 64x64 pixels, which is a good compromise; bigger buckets use more memory, while smaller buckets may perform redundant computations and filtering and thus render slower but give initial faster feedback."
    }
    parm {
        SOHO_TOGGLE(ar_progressive, "Progressive Refinement", "System", 1)
        nolabel
        joinnext
        help "Apply an iterative progressive render to the region tool, starting from the low Initial AA until the current AA samples values."
    }
    parm {
        SOHO_INT(ar_AA_initial, "Progressive AA", "System", -3)
        range { -3 0! }
        disablewhen "{ ar_progressive == 0 }"
        help "The initial AA samples used for the first progressive render. Negative values subsample the render, allowing faster feedback in the region tool."
    }
    parm {
        SOHO_FILE(ar_shader_searchpath, "Shader Path", "System", "")
        parmtag { "filechooser_mode" "read" }
        help "Specifies the directory where to search for dynamically loaded Arnold shaders."
    }
    parm {
        SOHO_FILE(ar_procedural_searchpath, "Procedural Path", "System", "")
        parmtag { "filechooser_mode" "read" }
        help "Specifies the directory where to search for dynamically loaded Arnold procedural nodes."
    }
    parm {
        SOHO_FILE(ar_texture_searchpath, "Texture Path", "System", "")
        parmtag { "filechooser_mode" "read" }
        help "Specifies the directory where to search for Arnold texture maps and IES files. This works in conjunction with the \"Save Texture Paths\" option in the ASS tab."
    }
    parm {
        SOHO_TOGGLE(ar_enable_bucket_work_sharing, "Bucket Work Sharing", "System", 1)
        help "Share work among all threads for the last remaining buckets."
    }
    parm {
        SOHO_TOGGLE(ar_inherit_properties, "Inherit Properties", "System", 0)
        help "Enable properties inheritance for geometry at the expense of translation time."
    }
    parm {
        SOHO_TOGGLE(ar_create_intermediate_directories, "Create Intermediate Directories", "System", 1)
        help "Create intermediate parent directories when rendering to image or ASS files."
    }
    parm {
        SOHO_TOGGLE(ar_parallel_node_init, "Parallel Node Initialization", "System", 0)
        help "Initialization and update of scene nodes can now be multi-threaded. This can significantly lower the scene preparation time in complex scenes with many objects, shaders or lights. For now, this option is disabled by default, to avoid issues with existing custom shaders or procedurals that may have hidden implicit dependencies between nodes, something which is not currently compatible with multi-threading. Please try this out and report any problems."
    }
    parm {
        SOHO_TOGGLE(ar_abort_on_error, "Abort On Error", "System", 1)
        help "Aborts rendering as soon as an error is detected. This is the recommended setting. In general, you should not ignore important error messages, or you'll risk crashes, rendering artifacts and undefined behaviour."
    }
    parm {
        SOHO_TOGGLE(ar_abort_on_license_fail, "Abort On License Fail", "System", 0)
        help "Aborts rendering if when the render starts the license is not detected. If not set and no license is found, images will be watermarked."
    }
    parm {
        SOHO_TOGGLE(ar_skip_license_check, "Skip License Check", "System", 0)
        help "Do not try to check out a license and thus render with watermarks."
    }
    parm {
        SOHO_STRING(ar_rop_uuid, "UUID", "System", "")
        invisible
        help "Unique number to identify the Arnold ROP."
    }
    parm {
        SOHO_FLOAT(ar_texture_gamma, "Texture Gamma", "System", 1)
        range { 0! 3 }
        help "Apply an inverse gamma correction to all texture lookups. For example, a value of 2.2 will linearize a texture that comes in with a gamma of 2.2."
    }
    parm {
        SOHO_FLOAT(ar_light_gamma, "Lights Gamma", "System", 1)
        range { 0! 3 }
        help "Apply an inverse gamma correction to the light color widget."
    }
    parm {
        SOHO_FLOAT(ar_shader_gamma, "Shaders Gamma", "System", 1)
        range { 0! 3 }
        help "Apply an inverse gamma correction to the shader color widget."
    }
    parm {
        SOHO_FLOAT(ar_bump_multiplier, "Bump Multiplier", "System", 1)
        range { 0! 3 }
        help "Multiplier to modify all bump values globally."
    }
    parm {
        SOHO_FLOAT(ar_ray_bias, "Ray Bias", "System", 1e-06)
        range { 0! 1 }
        help "Offset from the ray origin to prevent occasional errors caused from faces casting shadows on themselves or on adjacent faces."
    }
    parm {
        SOHO_TOGGLE(ar_shadow_terminator_fix, "Shadow Terminator Fix", "System", 1)
        help "???"
    }
    parm {
        SOHO_TOGGLE(ar_shadows_obey_light_linking, "Shadows Obey Light Linking", "System", 0)
        help "???"
    }
    parm {
        SOHO_TOGGLE(ar_skip_background_atmosphere, "Skip Background Atmosphere", "System", 0)
        help "???"
    }
    parm {
        SOHO_TOGGLE(ar_CCW_points, "CCW Points", "System", 1)
        help "??? Counter clockwire points."
    }
    parm {
        SOHO_TOGGLE(ar_GI_falloff_enabled, "Enable GI Falloff", "System", 0)
        help "???"
    }
    parm {
        SOHO_FLOAT(ar_GI_falloff_start_dist, "GI Falloff Start", "System", 1e+12)
        range { 0! 1000000 }
        help "???"
        disablewhen "{ ar_GI_falloff_enabled == 0 }"
    }
    parm {
        SOHO_FLOAT(ar_GI_falloff_stop_dist, "GI Falloff Stop", "System", 1e+12)
        range { 0! 1000000 }
        help "???"
        disablewhen "{ ar_GI_falloff_enabled == 0 }"
    }
    parm {
        SOHO_TOGGLE(ar_enable_displacement_derivs, "Enable Displacement Derivs", "System", 1)
        help "???"
    }
    parm {
        SOHO_TOGGLE(ar_enable_threaded_procedurals, "Enable Threaded Procedurals", "System", 1)
        help "???"
    }

    //////////////////////////////////////////////////////////////////////////
    // Diagnostics
    //
    
    collection {
    name    sep_diagnostics1
    label   "sep_diagnostics1"
    parmtag { spare_category "Diagnostics" }
        parm {
            name    "my_sep_diagnostics1"
            label   "Separator"
            type    separator
        }
    }
    collection {
    name    sep_diagnostics2
    label   "sep_diagnostics2"
    parmtag { spare_category "Diagnostics" }
        parm {
            name    "my_sep_diagnostics2"
            label   "Separator"
            type    separator
        }
    }
    
    parm {
        SOHO_TOGGLE(ar_log_console_enable, "Log to Console", "Diagnostics", 1)
        help "Log to console."
    }
    parm {
        SOHO_TOGGLE(ar_log_file_enable, "Log File", "Diagnostics", 0)
        nolabel
        joinnext
        help "Log to file"
    }
    parm {
        SOHO_FILE(ar_log_file, "Log to File", "Diagnostics", "")
        parmtag { "filechooser_mode" "write" }
        disablewhen "{ ar_log_file_enable == 0 }"
        help "Specifies the output path for Arnold log files."
    }
    parm {
        SOHO_STRING(ar_log_verbosity, "Log Verbosity", "Diagnostics", "warnings")
        menu {
            "warnings"  "Warnings Only"     
            "info"      "Info"              
            "detailed"  "Detailed"         
            "debug"     "Debug"             
        }
        joinnext
        help "Specifies the verbosity level and whether log messages are sent to the console or written to a file."
    }
    parm {
        SOHO_INT(ar_log_max_warnings, "   Max. Warnings", "Diagnostics", 5)
        range { 0! 1000 }
        help "Limits the number of warning messages that are sent to the console."
    }
    parm {
        SOHO_TOGGLE(ar_texture_per_file_stats, "Detailed Texture Statistics", "Diagnostics", 1)
        help "Enable per file texture statistics."
    }
    parm {
        SOHO_TOGGLE(ar_log_plugins, "Detailed Plugins Information", "Diagnostics", 0)
        help "Show details about plugins loaded."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_textures, "Ignore Textures", "Diagnostics", 0)
        help "Ignore all textures when rendering."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_shaders, "Ignore Shaders", "Diagnostics", 0)
        help "Ignore all shaders when rendering. By default Arnold will render with a simple \"N dot eye\" shader."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_atmosphere, "Ignore Atmosphere", "Diagnostics", 0)
        help "Ignore all atmospheric shaders."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_lights, "Ignore Lights", "Diagnostics", 0)
        help "Ignore all light sources."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_direct_lighting, "Ignore Direct Lighting", "Diagnostics", 0)
        help "Ignore all direct lighting."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_shadows, "Ignore Shadows", "Diagnostics", 0)
        help "Ignore shadows from all light sources."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_subdivision, "Ignore Subdivision", "Diagnostics", 0)
        help "No objects will be subdivided."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_displacement, "Ignore Displacement", "Diagnostics", 0)
        help "Displacements will be ignored."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_bump, "Ignore Bump", "Diagnostics", 0)
        help "Bump mapping will be ignored."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_motion_blur, "Ignore Motion Blur", "Motion Blur", 0)
        disablewhen "{ ar_mb_xform_enable == 0 ar_mb_dform_enable == 0 }"
        help "Ignore motion blur effects."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_dof, "Ignore Depth of Field", "Diagnostics", 0)
        help "Ignore depth of field effects."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_smoothing, "Ignore Normal Smoothing", "Diagnostics", 0)
        help "Polygon normals will not be smoothed, resulting in a faceted appearance."
    }
    parm {
        SOHO_TOGGLE(ar_ignore_sss, "Ignore Sub-Surface Scattering", "Diagnostics", 0)
        help "Ignore Subsurface Scattering calculations."
    }
    parm {
        SOHO_PARM(ar_error_color_bad_texture, "Bad Texture Color", "Diagnostics", color, 3, 1 0 0)
        help "Color to use for bad textures."
    }
    parm {
        SOHO_PARM(ar_error_color_bad_pixel, "NaN Pixel Color", "Diagnostics", color, 3, 0 0 1)
        help "Color to use for bad pixels (NaNs)."
    }
    parm {
        SOHO_PARM(ar_error_color_bad_shader, "Bad Shader Color", "Diagnostics", color, 3, 1 0 1)
        help "Color to use for bad shaders."
    }
    parm {
        SOHO_TOGGLE(ar_log_trace_enable, "Trace Log", "Diagnostics", 0)
        help "Enables extremely detailed HtoA debug messages."
    }
    parm {
        SOHO_TOGGLE(ar_extra_userdata, "Extra User Data", "Diagnostics", 0)
        help "Write additional motion sample times and vertex ordering information in the scene as user data."
    }
    
#include "override_parms.ds"
#include "object_parms.ds"
#include "instance_parms.ds"
#include "procedural_parms.ds"
#include "camera_parms.ds"

    //////////////////////////////////////////////////////////////////////////
    // Default ROP parameters
    //
    parm {
        name    default_output
        label   "Default Output"
        parmtag { spare_category    "__spare_parmlist" }
        parmtag { 
            spare_parmlist    "\
                ar_picture \
                override_camerares \
                res_fraction \
                override_resolution \
                overscan_resolution \
                ar_picture_format \
                ar_picture_tiling \
                ar_tiff_format \
                ar_tiff_compression \
                ar_png_format \
                ar_exr_compression \
                ar_jpeg_quality \
                ar_output_driver_gamma \
                ar_exr_half_precision \
                ar_exr_preserve_layer_name \
                ar_exr_autocrop \
                ar_picture_output_padded \
                ar_picture_dither \
                ar_tiff_unpremult_alpha \
                ar_tiff_skip_alpha \
                ar_deepexr_subpixel_merge \
                ar_deepexr_beauty_tolerance \
                ar_deepexr_alpha_tolerance \
                ar_deepexr_depth_tolerance \
                ar_deepexr_beauty_half_precision \
                ar_deepexr_alpha_half_precision \
                ar_deepexr_depth_half_precision \
                ar_deepexr_use_RGB_opacity \
                ar_deepexr_enable_filtering \
                ar_picture_append \
                ar_exr_metadata \
                sep_output1 \
                ar_pixel_filter_type \
                ar_pixel_filter_width \
                ar_pixel_filter_width_blackman_harris \
                ar_pixel_filter_width_sinc \
                ar_pixel_filter_farthest_domain \
                ar_pixel_filter_variance_scalar_mode \
                ar_pixel_filter_heatmap_minimum \
                ar_pixel_filter_heatmap_maximum \
                ar_AA_sample_clamp_enable \
                ar_AA_sample_clamp_affects_aovs \
                ar_AA_sample_clamp \
                sep_output2 \
                ar_enable_aov_composition \
                ar_multicam \
                ar_aovs \
                ar_overridden \
                \
                ar_AA_samples \
                ar_GI_diffuse_samples \
                ar_GI_glossy_samples \
                ar_GI_refraction_samples \
                ar_sss_bssrdf_samples \
                ar_volume_indirect_samples \
                ar_AA_seed \
                ar_sss_use_autobump \
                \
                ar_GI_total_depth \
                ar_GI_diffuse_depth \
                ar_GI_glossy_depth \
                ar_GI_reflection_depth \
                ar_GI_refraction_depth \
                ar_GI_volume_depth \
                ar_auto_transparency_depth \
                ar_auto_transparency_threshold \
                ar_low_light_threshold \
                \
                ar_mb_xform_enable \
                ar_mb_xform_keys \
                ar_mb_dform_enable \
                ar_mb_dform_keys \
                ar_mb_shutter \
                ar_mb_shutter_length \
                ar_mb_shutter_range \
                ar_reference_time \
                ar_ignore_motion_blur \
                ar_curved_motionblur \
                \
                ar_texture_max_sharpen \
                ar_texture_diffuse_blur \
                ar_texture_glossy_blur \
                ar_texture_max_memory_MB \
                ar_texture_max_open_files \
                ar_texture_accept_untiled \
                ar_texture_autotile \
                ar_texture_accept_unmipped \
                ar_texture_automip\
                ar_texture_use_existing_tx \
                ar_enable_fast_opacity \
                \
                ar_force_threads \
                ar_threads \
                ar_thread_priority \
                ar_bucket_scanning \
                ar_bucket_size \
                ar_progressive \
                ar_AA_initial \
                ar_shader_searchpath \
                ar_procedural_searchpath \
                ar_texture_searchpath \
                ar_create_intermediate_directories \
                ar_inherit_properties \
                ar_parallel_node_init \
                ar_enable_bucket_work_sharing \
                ar_abort_on_error \
                ar_abort_on_license_fail \
                ar_skip_license_check \
                ar_rop_uuid \
                \
                ar_log_file_enable \
                ar_log_file \
                ar_log_verbosity \
                ar_log_max_warnings \
                ar_log_console_enable \
                ar_texture_per_file_stats \
                ar_log_plugins \
                ar_log_trace_enable \
                ar_extra_userdata \
                sep_diagnostics1 \
                ar_ignore_textures \
                ar_ignore_shaders \
                ar_ignore_atmosphere \
                ar_ignore_lights \
                ar_ignore_direct_lighting \
                ar_ignore_shadows \
                ar_ignore_subdivision \
                ar_ignore_displacement \
                ar_ignore_bump \
                ar_ignore_smoothing \
                ar_ignore_dof \
                ar_ignore_sss \
                sep_diagnostics2 \
                ar_error_color_bad_texture \
                ar_error_color_bad_pixel \
                ar_error_color_bad_shader \
                "
        }
    }
}
