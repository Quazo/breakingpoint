<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>HtoA: Geometry translation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><img alt="Logo" src="solidangle_small.png"/></td>
  <td style="padding-left: 1em;">
   <div id="projectname">Arnold for Houdini Developer Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">HtoA Developer Guide</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Geometry translation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The geometry translation is a mix of Python and C++.</p>
<p>At a high level, the translation is done in Python through SOHO. This gives us the benefits of render property inheritance, render context overrides or SOHO clerks. This also enables users to easily customize any aspect of the translation.</p>
<p>Pure Python however, is notoriously slow, and the htoa_pygeo python module has been implemented in C++ with the HDK and does the heavy lifting of the geometry translation. The main classes of this module are presented below.</p>
<h1>Session </h1>
<p>The render/translation happens within a context represented by the <a class="el" href="classhtoa_1_1pygeo_1_1Session.html">htoa::pygeo::Session</a> class, that shares global parameters shared in the export. It usually maps to an Arnold ROP.</p>
<h1>Object </h1>
<p>The SOHO objects that Houdini yields in Python are mapped to <a class="el" href="classhtoa_1_1pygeo_1_1Object.html" title="SOHO Object representation. ">htoa::pygeo::Object</a> instances. Those usually maps to a Houdini OBJ node and a corresponding SOP node holding the geometry within it, but not always. For example, the SOP could reference another OBJ's contents in the case of instances.</p>
<h1>Translator </h1>
<p>The SOP contents are then partitioned by a series of <a class="el" href="classhtoa_1_1pygeo_1_1Translator.html">htoa::pygeo::Translator</a>, one for each primitive type or subset we want to translate. The definition of what part of the SOP geometry a Translator is going to take care of is deliberately vague. It could be a subset of primitive types, arbitrary tagged points in the geometry or even specific vertex indices.</p>
<p>This is the list of Translators implemented so far:</p>
<ul>
<li>Polygons (closed polygon primitives)</li>
<li>Curves (Bezier, NURBS, circle and open polygon primitives)</li>
<li>Particles (particle primitives)</li>
<li>Tessellated (miscellanous primitive types such as NURBS, Bezier patches, spheres or metaballs that need to be tessellated before being tranlated as polymeshes)</li>
</ul>
<h1>Partition </h1>
<p>The (internal) input of the Translator is defined by a <a class="el" href="classhtoa_1_1partition_1_1Partition.html" title="Partition base class. ">htoa::partition::Partition</a>. A Partition can select a subset of primitives, points or vertices of the geometry with an arbitrary filter, and this filter can be executed in parallel on the input geometry.</p>
<p>The result of the filter is presented as a GA_Range. This native Houdini class is compact, does not duplicates data and allows several mode of iteration other the actual geometry.</p>
<p>Among these iterators, a particularly interesting one allows to iterate other contiguous chunks of data, which is handy for vectorization. The iteration itself can be done in parallel most of the time.</p>
<h1>Node </h1>
<p>Each Translator can then create a set of <a class="el" href="classhtoa_1_1arnold_1_1Node.html">htoa::arnold::Node</a> instances, which are 1:1 mappings of the resulting Arnold nodes for geometry. The Translators will call the Node::gather() method on each of the Nodes at each of the deformation keys.</p>
<p>The Node instances, once instanced and gathered for each key, will contain all of the data necessary to actually build the Arnold node. The Node::build() method will do this work and create the corresponding Arnold node. This last step is kept separate on purpose. Because Arnold only hold a single universe per process, we don't want create the node in Arnold and clash with other nodes in the same process. This also makes it easier to eventually serialize the node data and pass it to a separate render process, or send updates for IPR.</p>
<p>The Node subclasses implemented so far are:</p>
<ul>
<li>Polymeshes</li>
<li>Curves</li>
<li>Points</li>
</ul>
<p>It's very convenient to separate the Translators from the Nodes, for example the Polygons and Tessellated translators are very different in essence but will both generate the same Polymesh node. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<br>
<address class="footer"><small>
HtoA 1.5.3 - &copy; 2014 <a href="http://www.solidangle.com">Solid Angle</a>
</small></address>
</body>
</html>
